from math import pi


# Рассмотрим работу lambda. Дан список, надо вернуть кортеж из чётных чисел этого списка + квадрат числа:

def select(func, collection):  # По своей сути эта функция является функцией map, о которой ниже.
    return [func(x) for x in collection]  # К каждому элементу списка применяем функцию из аргумента.


def where(func, collection):  # По своей сути эта функция является функцией filter, о которой ниже.
    return [x for x in collection if func(x)]  # Возвращает элемент только в том случае, если выполнилось условие
                                               # функции.


data = [1, 2, 3, 5, 8.95, 15, 23.5, 38]
all_int = select(int, data)
print(all_int)

all_even = where(lambda x: x % 2 == 0, all_int)
print(all_even)

result_list = select(lambda x: (x, x ** 2), all_even)
print(result_list)


# Функция map первым аргументом принимает другую функцию, а вторым объект. Таким образом, перебирается объект с
# применением нужной функции через функцию map:

list1 = [x for x in range(1, 21)]
print(list1)

sum_10_in_list = list(map(lambda x: x + 10, list1))
print(sum_10_in_list)


# Рассмотрим функцию filter. Она возвращает только те элементы объекта, для которых True:

some_list = [15, 65, 9, 36, 175]
res = list(filter(lambda x: x % 10 == 5, some_list))
print(res)


# Рассмотрим функцию zip. Она применяется к набору итерируемых объектов и возвращает итератор с кортежами из элементов
# входных данных. zip([1, 2, 3], ['о', 'д', 'г'], ['f', 's', 't']) -> [(1, 'о', 'f'), (2, 'д', 's'), (3, 'г', 't')].
# Т.е. на выходе получаем набор данных, состоящий из элементов соответствующих исходному набору.

users = ['user1', 'user2', 'user3', 'user4', 'user5']
ids = [4, 5, 9, 14, 7]
salary = [111, 222, 333]
DB = list(zip(users, ids, salary))  # При передаче одного из списков меньшего размера, чем остальные, то zip будет
# пробегать только по минимальному количеству элементов всех списков.
print(DB)


# Функция enumerate применяется к итерируемому объекту и возвращает новый итератор с кортежами из индекса и элементов
# входных данных

print(list(enumerate(['Казань', 'Москва', 'Смоленск', 'Екатеринбург'], 1)))  # Если не указать последний аргументом
# цифру, с которой начинается отсчёт, то отчёт пойдёт с нуля.


"""
Файлы.
Варианты режима (мод) работы с файлами:
    'a' - открытие для добавления данных:
        * позволяет дописывать что-то в имеющийся файл;
        * если попробовать дописать что-то в несуществующий файл, то файл будет создан и в него начнётся запись;
    'r' - открытие для чтения данных:
        * позволяет читать данные из файла;
        * если попробовать считать данные из файла, которого не существует, то программа выдаст ошибку;
    'w' - открытие для записи данных в файл:
        * позволяет записывать/перезаписывать данные в существующем файле (все старые данные удалятся);
        * если попробовать записать что-то в несуществующий файл, то файл будет создан и в него начнётся запись.

Миксованные режимы:
    'w+' - открытие для записи данных в файл + чтение данных в файле:
        * позволяет записывать/перезаписывать данные в существующем файле (все старые данные удалятся);
        * позволяет читать данные из файла;
        * если прочитать/записать что-то в несуществующий файл, то файл будет создан и в него начнётся запись;
    'r+' - открытие для чтения данных + дозапись файла:
        * позволяет читать данные из файла;
        * позволяет дописывать что-то в имеющийся файл;
        * если попробовать считать/дописать данные из файла, которого не существует, то программа выдаст ошибку.
        
------------------------------------------------------------------------------------------------------------------------
        
Модуль os.
Модуль os предоставляет множество функций для работы с операционной системой, причём их поведение, как правило, не 
зависит от ОС, поэтому программы остаются переносимыми.
Для того, чтобы начать работать с данным модулем необходимо импортировать одноимённую библиотеку в свой файл.

Базовые функции модуля:
os.chdir(path) - смена текущей директории.
os.getcwd() - текущая рабочая директория.
os.path - является вложенным модулем в модуль os и реализует некоторые полезные функции для работы с путями, такие как:
    os.path.basename(path) - базовое имя пути;
    os.path.abspath(path) - возвращает нормализированный абсолютный путь.
    
------------------------------------------------------------------------------------------------------------------------

Модуль shutil.
Модуль shutil содержит набор функций высокого уровня для обработки файлов, групп файлов, и папок. В частности,
доступные здесь функции позволяют копировать, перемещать и удалять файлы и папки. Часто используется вместе
с модулем os.
Для того, чтобы начать работать с данным модулем необходимо импортировать одноимённую библиотеку.
Базовые функции:
shutil.copyfile(src, dst) - копирует содержимое (но не метаданные) файла src в файл dst.
shutil.copy(src, dst) - копирует содержимое файла src в файл или папку dst.
shutil.rmtree(path) - Удаляет текущую директорию и все поддиректории; path должен указывать на
директорию, а не на символическую ссылку.
"""

# ----------------------------------------------------------------------------------------------------------------------

# Планеты вращаются вокруг звезд по эллиптическим орбитам. Назовем самой далекой планетой ту, орбита которой имеет самую
# большую площадь. Напишите функцию find_farthest_orbit(list_of_orbits), которая среди списка орбит планет найдет ту, по
# которой вращается самая далекая планета. Круговые орбиты не учитывайте: вы знаете, что у вашей звезды таких планет
# нет, зато искусственные спутники были были запущены на круговые орбиты. Результатом функции должен быть кортеж,
# содержащий длины полуосей эллипса орбиты самой далекой планеты. Каждая орбита представляет из себя кортеж из пары
# чисел - полуосей ее эллипса. Площадь эллипса вычисляется по формуле S = pi*a*b, где a и b - длины полуосей эллипса.
# При решении задачи используйте списочные выражения. Подсказка: проще всего будет найти эллипс в два шага: сначала
# вычислить самую большую площадь эллипса, а затем найти и сам эллипс, имеющий такую  площадь. Гарантируется, что самая
# далекая планета ровно одна
# Пример ввода и вывода данных представлены на следующем слайде
# Ввод:
# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
# print(*find_farthest_orbit(orbits))
# Вывод:
# 2.5 10


# Функция с циклом:
def find_farthest_orbit_cycle(list_of_orbits):
    S = 0
    temp = 0
    for a, b in list_of_orbits:
        if S < pi * a * b:
            S = pi * a * b
            temp = (a, b)

    return temp


orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
print(find_farthest_orbit_cycle(orbits))


# Функция с генератором списка:
def find_farthest_orbit(list_of_orbits):
    list_comp = [pi * a * b for a, b in list_of_orbits]
    max_S = max(list_comp)
    tuple_index = list_comp.index(max_S)

    return list_of_orbits[tuple_index]


orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
print(find_farthest_orbit(orbits))


# Напишите функцию same_by(characteristic, objects), которая проверяет, все ли объекты имеют одинаковое значение
# некоторой характеристики, и возвращают True, если это так. Если значение характеристики для разных объектов отличается
# - то False. Для пустого набора объектов, функция должна возвращать True. Аргумент characteristic - это функция,
# которая принимает объект и вычисляет его характеристику.
# Ввод:							Вывод:
# values = [0, 2, 10, 6]				same
# if same_by(lambda x: x % 2, values):
# 	print(‘same’)
# else:
# 	print(‘different’)

def same_by(characteristic, objects):
    return len(list(filter(characteristic, objects))) == len(objects)


values = [0, 2, 10, 6, 7]

if not values:
    print('same')
elif same_by(lambda x: x % 2 == 0, values):
    print('same')
else:
    print('different')
