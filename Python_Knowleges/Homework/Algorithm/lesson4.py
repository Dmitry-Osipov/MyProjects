from collections import deque

"""
Дерево - это структура данных, представленная в виде набора связанных узлов. Для дерева характерно следующее: самый
верхний узел, который не имеет родителей, - это корень. Все элементы дерева - это узлы. При этом узлы, которые не
имеют детей, - это листья. Для деревьев нехарактерен двусвязный формат, ибо зачастую, мы не храним ссылки на наши листы,
а любой обход будет начинаться с корня, соответственно, вверх по дереву в большинстве случаев нам ходить не нужно.

Как можно работать с деревом?
Обход в глубину - это рекурсивный обход узлов дерева (самый часто используемый и самый простой).

Обход в ширину - циклический обход узлов дерева. В нём мы проверяем каждый уровень нашего дерева отдельно. Сначала root,
потом всех его детей, потом всех детей их детей и т.д.

Следующая структура данных - это хэш-таблица.
Хэш-таблица представляет собой ассоциативный массив, использующий хэш-функцию для выполнения операций добавления,
удаления и поиска элементов.
В свою очередь ассоциативным массивом называют структуру данных, которая хранит пару ключ-значение, где ключ каждой пары
является уникальным в пределах всего массива данных.
Огромным плюсом хэш-таблиц является сложность операций с ними - O(1).
Скорость работы хэш-таблицы обусловлена хэш-функцией. Хэш-функция - это специальный алгоритм, позволяющий преобразовать
входные данные произвольного размера и состава в битовую строку фиксированной длины. Популярные хэш-алгоритмы: MD5,
SHA-1, SHA-256, SHA-384, SHA-512.
При этом, хэш-функция является необратимой. Из хэша назад получить значение невозможно, потому что каждому хэшу может
соответствовать большое количество значений. Именно поэтому это называется односторонней функцией. Само по себе
хэширование очень популярно. Почти всё шифрование использует ту или иную хэш-функцию.
"""


class Node:
    """
    Это определение класса Node, представляющего узел дерева. Каждый узел имеет свое значение (value) и список дочерних
    узлов (children).
    """

    def __init__(self, value):
        self.value = value
        self.children = []


class Tree:
    """
    Это определение класса Tree, представляющего собой дерево.
    """

    def __init__(self):
        """
        В конструкторе (__init__) устанавливается корневой узел (root) равным None.
        """
        self.root = None

    def _dfs(self, node, value):
        """
        Это приватный метод для рекурсивного поиска в глубину (DFS). Он принимает текущий узел (node) и искомое значение
        (value). Если текущий узел равен None, возвращается False. Если значение текущего узла равно искомому значению,
        возвращается True. Затем мы рекурсивно вызываем этот метод для каждого дочернего узла.

        :param node: Текущий узел - root, далее его дети.
        :param value: Искомое значение - целое число.
        :return: Булева-значение.
        """
        if node is None:
            return False

        if node.value == value:
            return True

        for child in node.children:
            if self._dfs(child, value):
                return True

        return False

    def dfs_contains(self, value):
        """
        Это публичный метод для выполнения поиска в глубину (DFS). Он вызывает приватный метод _dfs и передает ему
        корневой узел дерева и искомое значение. Если _dfs возвращает True, то dfs_contains также возвращает True, что
        указывает на то, что значение найдено в дереве. В противном случае, возвращается False.

        :param value: Искомое значение - целое число.
        :return: Булева-значение.
        """
        return self._dfs(self.root, value)

    def _bfs(self, value):
        """
        Это приватный метод для поиска в ширину (BFS). Он использует очередь queue для обхода узлов в ширину. Если
        корневой узел дерева равен None, он возвращает False. В противном случае, мы начинаем с корневого узла и
        добавляем его в очередь. Затем мы пока не опустошим очередь, извлекаем узел, проверяем его значение, и если оно
        совпадает с искомым значением, возвращаем True. Если не совпадает, мы добавляем все дочерние узлы текущего узла
        в очередь для дальнейшего обхода.

        :param value: Искомое значение - целое число.
        :return: Булева-значение.
        """
        if self.root is None:
            return False

        queue = deque()
        queue.append(self.root)

        while queue:
            node = queue.popleft()
            if node.value == value:
                return True
            queue.extend(node.children)

        return False

    def bfs_contains(self, value):
        """
        Это публичный метод для выполнения поиска в ширину (BFS). Он вызывает приватный метод _bfs и передает ему
        искомое значение. Если _bfs возвращает True, то bfs_contains также возвращает True, что указывает на то, что
        значение найдено в дереве. В противном случае, возвращается False.

        :param value: Искомое значение - целое число.
        :return: Булева-значение.
        """
        return self._bfs(value)


# Пример использования.
# Создаем экземпляр класса Tree:
my_tree = Tree()

# Создаем узлы и добавляем их к дереву:
root_node = Node(1)
child1 = Node(2)
child2 = Node(3)
child3 = Node(4)
child4 = Node(5)

# Мы расширяем список children у корневого узла root_node, добавляя в него узлы child1, child2 и child3. Это означает,
# что у корневого узла теперь есть три дочерних узла:
root_node.children.extend([child1, child2, child3])

# Мы добавляем узел child4 в список children узла child2. Теперь child2 имеет дополнительного потомка child4:
child2.children.append(child4)

# Мы устанавливаем корневой узел дерева my_tree равным root_node. Теперь my_tree представляет собой дерево с корневым
# узлом root_node, который, в свою очередь, имеет своих дочерних потомков, включая child1, child2, child3 и child4:
my_tree.root = root_node

# Поиск в глубину
value_to_find = 4
print(f"DFS: {my_tree.dfs_contains(value_to_find)}")
value_to_find = 41
print(f"DFS: {my_tree.dfs_contains(value_to_find)}")

# Поиск в ширину
value_to_find = 4
print(f"BFS: {my_tree.bfs_contains(value_to_find)}")
value_to_find = 41
print(f"BFS: {my_tree.bfs_contains(value_to_find)}")

"""
Бинарное дерево - частный случай дерева, где все элементы обязательно строго уникальны, каждый родитель имеет не более
2 детей, при этом левый ребёнок всегда меньше родителя, а правый - больше. Засчёт этого не пригодна для работы с
иерархией в компании или с отображением файловой системы. Но есть и свои плюсы. Например, для поиска элемента бинарное
дерево не нужно перебирать целиком, ибо находясь на каждом узле, мы всегда точно понимаем, где именно мы будем искать
элемент. Поэтому бинарные деревья используются для хранения одного типа данных и ускоренного доступа к ним.
Частным случаем бинарного дерева для таких задач является сбалансированное дерево, у которого выполняется следующее
требование: для любого узла дерева высота его правого поддерева отличается от высот левого поддерева не более чем на
единицу. Сбалансированное дерево даёт нам идеальную структуру для бинарного поиска. Корень такого дерева - это его
центральный элемент. Количество элементов справа и слева от него различается не более чем на единицу, что характерно для
выбора стартовой позиции в бинарном поиске. Таким образом, сложность поиска по сбалансированному дереву составляет
O(log(n)), что даёт очень высокую производительность. Сбалансированное дерево также имеет особенности: если мы добавляем
в него элемент, то мы должны всегда чётко понимать, куда конкретно внутри нашего дерева требуется добавить элемент,
чтобы оно сохраняло свою сбалансированность, поэтому для любого сбалансированного дерева характерны любые операции
балансировки, чтобы при динамическом расширении данного дерева мы сохраняли свойства и скорость поиска.
Существуют различные типы балансировки. Самым классическим и базовым является AVL-дерево, оно имеет сложную формулу
балансировки, но оно позволяет гарантированно создавать корректно сбалансированное дерево с разницей глубины каждого
поддерева не более единицы. Для совершения этих операций каждая нода хранит помимо информации о своём значении и детях,
также дополнительно будет хранить информацию о своей глубине. И на основе информации о глубине происходит определённый
анализ, который для каждой операции вставки или удаления будет производить корректировку узлов в случае необходимости.

Рассмотрим красно-чёрное дерево:
1) каждый узел может быть либо чёрным, либо красным и иметь двух потомков;
2) корень всегда чёрный;
3) дети красного узла обязательно чёрные;
4) для частного случая - левостороннее красно-чёрное дерево - также применяется критерий: красный узел может быть только
левым потомком.
"""


class RedBlackTree:
    """
    Класс красно-чёрного дерева. Внутри него определены константы RED и BLACK для представления цветов узлов. Также есть
    внутренний класс Node, который представляет узел дерева. Узел содержит ключ (key), значение (value), цвет (color) и
    ссылки на левого и правого потомка.
    """
    RED = True
    BLACK = False

    class Node:
        def __init__(self, key, value, color, left=None, right=None):
            self.key = key
            self.value = value
            self.color = color
            self.left = left
            self.right = right

    def __init__(self):
        """
        Конструктор __init__ инициализирует дерево, устанавливая корневой узел (изначально None).
        """
        self.root = None

    def _is_red(self, node):
        """
        Вспомогательная функция, проверяющая, является ли узел красным. Если узел равен None, то он считается черным.

        :param node: Узел - экземпляр класса Node.
        :return: Булева-значение - True для красного и None для черного.
        """
        if node is None:
            return False
        return node.color == self.RED

    def _rotate_left(self, h):
        """
        Функция выполняет левое вращение вокруг узла h. Это операция для балансировки дерева.

        :param h: Узел - экземпляр класса Node.
        :return: Новый корневой узел после вращения.
        """
        x = h.right
        h.right = x.left
        x.left = h
        x.color = h.color
        h.color = self.RED
        return x

    def _rotate_right(self, h):
        """
        Функция выполняет правое вращение вокруг узла h. Это также операция для балансировки.

        :param h: Узел - экземпляр класса Node.
        :return: Новый корневой узел после вращения.
        """
        x = h.left
        h.left = x.right
        x.right = h
        x.color = h.color
        h.color = self.RED
        return x

    def _flip_colors(self, h):
        """
        Функция меняет цвета узлов. Это используется при балансировке дерева.

        :param h: Узел - экземпляр класса Node.
        """
        h.color = not h.color
        h.left.color = not h.left.color
        h.right.color = not h.right.color

    def put(self, key, value):
        """
        Публичный метод для вставки ключа и значения в дерево. Он вызывает приватный метод _put, затем устанавливает
        корневой узел в черный цвет, чтобы удовлетворить свойства красно-чёрного дерева.

        :param key: Ключ для вставки.
        :param value: Значение для вставки.
        """
        self.root = self._put(self.root, key, value)
        self.root.color = self.BLACK

    def _put(self, h, key, value):
        """
        Приватный метод для рекурсивной вставки ключа и значения в дерево. Он учитывает правила балансировки и цвета
        узлов. Метод возвращает изменённый узел.

        :param h: Текущий узел - экземпляр класса Node.
        :param key: Ключ для вставки.
        :param value: Значение для вставки.
        :return: Узел после вставки.
        """
        if h is None:
            return self.Node(key, value, self.RED)

        if key < h.key:
            h.left = self._put(h.left, key, value)
        elif key > h.key:
            h.right = self._put(h.right, key, value)
        else:
            h.value = value

        if self._is_red(h.right) and not self._is_red(h.left):
            h = self._rotate_left(h)
        if self._is_red(h.left) and self._is_red(h.left.left):
            h = self._rotate_right(h)
        if self._is_red(h.left) and self._is_red(h.right):
            self._flip_colors(h)

        return h

    def get(self, key):
        """
        Публичный метод для поиска значения по ключу. Он выполняет поиск в дереве и возвращает значение,
        если ключ найден.

        :param key: Ключ для поиска.
        :return: Значение, соответствующее ключу.
        """
        x = self.root
        while x is not None:
            if key < x.key:
                x = x.left
            elif key > x.key:
                x = x.right
            else:
                return x.value
        return None

    def contains(self, key):
        """
        Публичный метод для проверки наличия ключа в дереве. Он использует метод get и возвращает True, если ключ
        найден, и False в противном случае.

        :param key: Ключ для проверки.
        :return: Булево значение - True, если ключ найден, и False в противном случае.
        """
        return self.get(key) is not None

    def delete(self, key):
        """
        Публичный метод для удаления ключа из дерева. Он проверяет наличие ключа, изменяет цвет корневого узла
        на красный (для упрощения удаления), вызывает приватный метод _delete, а затем устанавливает цвет корневого узла
        в черный (для удовлетворения свойств красно-чёрного дерева).

        :param key: Ключ для удаления.
        """
        if not self.contains(key):
            return
        if not self._is_red(self.root.left) and not self._is_red(self.root.right):
            self.root.color = self.RED
        self.root = self._delete(self.root, key)
        if self.root is not None:
            self.root.color = self.BLACK

    def _delete(self, h, key):
        """
        Приватный метод для рекурсивного удаления ключа из дерева. Он также учитывает правила балансировки и цвета узлов

        :param h: Текущий узел - экземпляр класса Node.
        :param key: Ключ для удаления.
        """
        if key < h.key:
            if not self._is_red(h.left) and not self._is_red(h.left.left):
                h = self._move_red_left(h)
            h.left = self._delete(h.left, key)
        else:
            if self._is_red(h.left):
                h = self._rotate_right(h)
            if key == h.key and h.right is None:
                return None
            if not self._is_red(h.right) and not self._is_red(h.right.left):
                h = self._move_red_right(h)
            if key == h.key:
                x = self._min(h.right)
                h.key, h.value = x.key, x.value
                h.right = self._delete_min(h.right)
            else:
                h.right = self._delete(h.right, key)
        return self._balance(h)

    def _delete_min(self, h):
        """
        Приватный метод для удаления минимального ключа из дерева.

        :param h: Текущий узел - экземпляр класса Node.
        """
        if h.left is None:
            return None
        if not self._is_red(h.left) and not self._is_red(h.left.left):
            h = self._move_red_left(h)
        h.left = self._delete_min(h.left)
        return self._balance(h)

    def _move_red_left(self, h):
        """
        Приватный метод для перемещения красной ссылки влево. Это используется при удалении ключа.

        :param h: Текущий узел - экземпляр класса Node.
        """
        self._flip_colors(h)
        if self._is_red(h.right.left):
            h.right = self._rotate_right(h.right)
            h = self._rotate_left(h)
            self._flip_colors(h)
        return h

    def _move_red_right(self, h):
        """
        Приватный метод для перемещения красной ссылки вправо. Также используется при удалении.

        :param h: Текущий узел - экземпляр класса Node.
        """
        self._flip_colors(h)
        if self._is_red(h.left.left):
            h = self._rotate_right(h)
            self._flip_colors(h)
        return h

    def _balance(self, h):
        """
        Приватный метод для балансировки узла после удаления.

        :param h: Текущий узел - экземпляр класса Node.
        """
        if self._is_red(h.right):
            h = self._rotate_left(h)
        if self._is_red(h.left) and self._is_red(h.left.left):
            h = self._rotate_right(h)
        if self._is_red(h.left) and self._is_red(h.right):
            self._flip_colors(h)
        return h

    def _min(self, h):
        """
        Приватный метод для поиска минимального ключа в дереве.

        :param h: Текущий узел - экземпляр класса Node.
        :return: Минимальный ключ в дереве.
        """
        while h.left is not None:
            h = h.left
        return h

    def dfs_contains(self, key):
        """
        Публичный метод для поиска значения по ключу с использованием обхода в глубину (DFS).

        :param key: Ключ для поиска.
        :return: Булево значение - True, если ключ найден, и False в противном случае.
        """
        stack = [self.root]
        while stack:
            node = stack.pop()
            if node is not None:
                if key == node.key:
                    return True
                stack.append(node.left)
                stack.append(node.right)
        return False

    def bfs_contains(self, key):
        """
        Публичный метод для поиска значения по ключу с использованием обхода в ширину (BFS). Он начинает с корневого
        узла и проверяет каждый узел поочередно, используя очередь для обхода узлов на разных уровнях. Если ключ найден,
        метод возвращает True, в противном случае - False.

        :param key: Ключ для поиска.
        :return: Булево значение - True, если ключ найден, и False в противном случае.
        """
        if self.root is None:
            return False

        queue = deque()
        queue.append(self.root)

        while queue:
            node = queue.popleft()
            if node.key == key:
                return True
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        return False

    def inorder_traversal(self):
        """
        Публичный метод для выполнения инфиксного обхода дерева. Он возвращает список пар ключ-значение в
        отсортированном порядке. Это полезно для получения всех элементов дерева в упорядоченном виде.

        :return: Список пар ключ-значение в порядке возрастания ключей.
        """
        result = []
        self._inorder(self.root, result)
        return result

    def _inorder(self, node, result):
        """
        Вспомогательная рекурсивная функция, используемая методом inorder_traversal. Она выполняет инфиксный обход
        дерева, добавляя узлы в список result в порядке возрастания ключей.

        :param node: Текущий узел - экземпляр класса Node.
        :param result: Список для добавления элементов.
        """
        if node:
            self._inorder(node.left, result)
            result.append((node.key, node.value))
            self._inorder(node.right, result)


# Пример использования:
rb_tree = RedBlackTree()
rb_tree.put(10, "A")
rb_tree.put(20, "B")
rb_tree.put(5, "C")
rb_tree.put(15, "D")
rb_tree.put(25, "E")

print(rb_tree.dfs_contains(20))  # True
print(rb_tree.dfs_contains(30))  # False

print(rb_tree.bfs_contains(10))  # True
print(rb_tree.bfs_contains(30))  # False

rb_tree.delete(15)
print(rb_tree.dfs_contains(15))  # False

print(rb_tree.inorder_traversal())  # [(5, 'C'), (10, 'A'), (20, 'B'), (25, 'E')]

# ----------------------------------------------------------------------------------------------------------------------
# Семинар:

# 1. Начинаем реализацию хэш-таблицы с подготовки структуры и
# необходимых классов.
# 2. Давайте напишем реализацию односвязного списка, в котором мы
# и будем хранить пары ключ-значение.
# 3. Стоит обратить внимание, что можно использовать как дженерики, для обобщения возможных типов ключей и значений, так
# и заранее определить для себя конкретные типы, которые будут использоваться в качестве ключа и значения. Оба подхода
# допустимы для реализации
# 4. Добавляем массив связных списков с фиксированным размером (массив
# бакетов), либо передаваемым в конструкторе.
# 5. Хэш-таблица оперирует индексами, потому массив будет идеальным вариантом для представления бакетов.
# 6. Также реализуем метод вычисления индекса на основании хэш-кода ключа.
# 7. Реализуем метод поиска данных по ключу в хэш-таблице.
# 8. Теперь, когда у нас есть базовая структура нашей хэш-таблицы, можно написать алгоритм поиска элементов, включающий
# в себя поиск нужного бакета и поиск по бакету.
# 9. Необходимо реализовать методы добавления элементов в связный список, если там еще нет пары с аналогичным ключом и
# удаления элемента с аналогичным ключом из списка.
# 10. Все значения ключей в хэш-таблице уникальны, а значит и в каждом из связных список это правило будет также
# выполняться.


class HashTableNode:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None


class HashTable:
    def __init__(self, initial_size=10, load_factor=0.75):
        """
         Конструктор, который вызывается при создании нового объекта этого класса. Принимает два аргумента:
         initial_size (начальный размер хеш-таблицы) и load_factor (значение, которое будет использоваться для
         определения, когда нужно увеличивать размер таблицы из-за нагрузки).

        :param initial_size: Начальный размер хэш-таблицы - целое число, по умолчанию 10.
        :param load_factor: Процентное число, переведённое в дробь, - значение, которое используется для определения,
        когда требуется увеличить размер таблицы, чтобы не было перегрузки - дробное число, по умолчанию 0.75.
        Рекомендуемое значение находится в диапазоне от 0.5 до 0.75.
        """
        self.size = initial_size
        self.load_factor = load_factor
        self.buckets = [None] * self.size  # Здесь создается список buckets, который представляет собой массив бакетов
        # (каждый бакет - это связанный список элементов). Этот список инициализируется значением None и имеет длину,
        # равную self.size, то есть начальному размеру таблицы.
        self.count = 0  # Эта строка создает атрибут count и инициализирует его значением 0. Этот атрибут будет
        # использоваться для отслеживания количества элементов в хеш-таблице.

    def _hash_function(self, key):
        """
        Этот код представляет собой реализацию хеш-функции _hash_function, которая принимает ключ key, суммирует ASCII
        коды всех символов в ключе и затем возвращает остаток от деления этой суммы на размер (количество бакетов)
        хеш-таблицы self.size.

        :param key: Ключ, который требуется хэшировать для нашей хэш-таблицы.
        :return: Индекс, определяющий, в какой бакет мы положим наш хэш ключа + значение - целое число.
        """
        hash_sum = sum(ord(char) for char in key)  # Создаём уникальное числовое представление для каждого ключа.
        return hash_sum % self.size  # Мы берем остаток от деления этой суммы на размер хеш-таблицы self.size.
        # Это означает, что результат будет всегда находиться в диапазоне от 0 до self.size - 1, что делает его
        # индексом в массиве бакетов. Таким образом, каждому ключу будет назначен уникальный индекс в таблице.

    def _resize(self, new_size):
        """
        Этот метод используется для изменения размера хеш-таблицы на новый размер new_size.

        :param new_size: Значение, на которое мы увеличим количество бакетов в хэш-таблице - целое число.
        """
        new_buckets = [None] * new_size  # Создается новый массив new_buckets размером new_size, который будет
        # представлять новую хеш-таблицу. Изначально все его элементы устанавливаются в None.

        # Этот цикл перебирает все существующие бакеты (старые бакеты) в текущей хеш-таблице self.buckets.
        for bucket in self.buckets:
            current_node = bucket  # Создается переменная current_node, устанавливается в начало текущего бакета,
                                   # чтобы начать перебор элементов в этом бакете.
            while current_node:  # Этот цикл перебирает все элементы в текущем бакете (в связном списке), пока
                                 # не достигнет конца списка (когда current_node становится None).
                key, value = current_node.key, current_node.value  # Для каждого элемента в текущем бакете извлекаются
                                                                   # ключ key и значение value.
                index = self._hash_function(key) % new_size  # Вычисляется новый индекс index для элемента, используя
                # хеш-функцию и новый размер. Это определяет, в какой новый бакет должен быть помещен элемент.
                new_node = HashTableNode(key, value)  # Создается новый узел new_node с ключом и значением,
                                                      # извлеченными из текущего элемента.
                if not new_buckets[index]:  # Проверяется, пуст ли новый бакет по индексу index,
                    new_buckets[index] = new_node  # если бакет пуст, то new_node становится его первым элементом.
                else:  # В противном случае, если в новом бакете уже есть элементы, то new_node добавляется в начало
                    # связного списка, представляющего новый бакет. Таким образом, мы обрабатываем возможные коллизии.
                    new_node.next = new_buckets[index]
                    new_buckets[index] = new_node
                current_node = current_node.next

        self.buckets = new_buckets  # После переноса всех элементов из старых бакетов в новые, обновляем ссылку
        # self.buckets, чтобы она указывала на новый массив бакетов new_buckets.
        self.size = new_size  # Обновляем размер хеш-таблицы self.size, чтобы он соответствовал новому размеру new_size.

    def _check_resize(self):
        """
        Метод проверяет, нужно ли изменять размер хеш-таблицы на основе текущего load factor (фактора загрузки).
        """
        load = self.count / self.size  # Здесь вычисляется текущий load factor. Мы делим текущее количество элементов
        # на размер хеш-таблицы. Это показывает, насколько "загружена" текущая хеш-таблица.
        if load >= self.load_factor:  # Если коэффициент больше либо равен текущему фактору загрузки,
            new_size = self.size * 2  # то увеличиваем размер вдвое.
            self._resize(new_size)  # Вызываем метод _resize с новым размером, чтобы выполнить изменение размера
            # хеш-таблицы. Этот метод перераспределит элементы по новым бакетам в соответствии с новым размером.

    def put_key_and_value(self, key, value):

        index = self._hash_function(key)  # Вычисляем индекс бакета.
        new_node = HashTableNode(key, value)  # Создаем новый узел.

        if not self.buckets[index]:  # Если бакет пуст,
            self.buckets[index] = new_node  # то просто помещаем новый узел в него.
        else:  # В случае коллизии, добавляем новый узел в начало связного списка.
            new_node.next = self.buckets[index]
            self.buckets[index] = new_node

        self.count += 1  # Увеличиваем счетчик элементов.
        self._check_resize()  # Проверяем необходимость изменения размера.

    def get_value(self, key):
        """
        Метод используется для поиска значения по заданному ключу в хеш-таблице.

        :param key: Ключ.
        :return: Значение по хэшу ключа либо None.
        """
        index = self._hash_function(key)  # Здесь мы вычисляем индекс бакета, в котором, предположительно, находится
        # значение с заданным ключом. Для этого используется хеш-функция _hash_function, которая преобразует ключ key
        # в индекс бакета.

        # Перебираем связный список в бакете, чтобы найти элемент с заданным ключом.
        current_node = self.buckets[index]
        while current_node:
            if current_node.key == key:
                return current_node.value  # Если совпало значение хэша ключа в элементе, то возвращаем значение.
            current_node = current_node.next

        return None  # Если элемент не найден, возвращаем None.

    def remove_key(self, key):
        """
        Метод удаляет элемент из хеш-таблицы по заданному ключу, используя хэш ключа.

        :param key: Ключ.
        """

        index = self._hash_function(key)  # Вычисляем индекс бакета.

        current_node = self.buckets[index]  # Мы инициализируем переменную current_node значением из бакета, который
        # соответствует вычисленному индексу. Это начальная точка для поиска.
        prev_node = None  # Мы инициализируем переменную prev_node как None. Она будет использоваться для отслеживания
        # предыдущего узла в связанном списке. Т.е. при переходе на следующий узел current_node станет prev_node.

        # Перебираем связный список, чтобы найти элемент с заданным хэшем ключа.
        while current_node:
            if current_node.key == key:  # На каждой итерации цикла мы проверяем, является ли ключ текущего элемента
                                         # current_node.key равным заданному ключу key.
                # Теперь у нас есть два возможных случая, которые мы рассматриваем:
                if not prev_node:
                    # Если это первый узел в бакете, то мы обновляем указатель на начало бакета
                    # (self.buckets[index]) так, чтобы он указывал на следующий узел после current_node. По сути,
                    # мы удаляем current_node из начала бакета.
                    self.buckets[index] = current_node.next
                else:
                    # Иначе текущий узел находится в середине или в конце связанного списка. Тогда мы делаем следующее:
                    # мы обновляем указатель next предыдущего узла (prev_node.next) так, чтобы он указывал на следующий
                    # узел после current_node. Это пропускает current_node и удаляет его из связанного списка.
                    prev_node.next = current_node.next
                return
            prev_node = current_node  # Мы обновляем переменную prev_node, чтобы она указывала на текущий узел
            # current_node. Это необходимо для того, чтобы знать предыдущий узел в связанном списке. Перед началом цикла
            # prev_node равно None, но после первой итерации цикла оно становится равным текущему узлу current_node.
            # Это позволяет нам сохранить ссылку на предыдущий узел, чтобы мы могли обновить его указатель next, если
            # найдем элемент для удаления.
            current_node = current_node.next  # Мы обновляем переменную current_node, чтобы она указывала на следующий
            # узел в связанном списке. Это необходимо для продолжения перебора списка и проверки следующего узла на
            # соответствие заданному ключу. После этой операции current_node будет указывать на следующий узел списка.

    def __str__(self):
        """
        Метод отвечает за вывод каждого бакета в хэш-таблице в формате вложенного кортежа во вложенный список:
        [[(Ключ + значение)], ...]

        :return: Ключ + значение - список.
        """
        result = []
        for bucket in self.buckets:
            values = []
            current_node = bucket
            while current_node:
                values.append((current_node.key, current_node.value))
                current_node = current_node.next
            result.append(values)
        return str(result)


hash_table = HashTable()

# Добавляем пару ключ-значение в таблицу
hash_table.put_key_and_value("apple", 5)

# Получаем значение по ключу
value = hash_table.get_value("apple")
print(f"Значение для ключа 'apple': {value}")

# Удаляем ключ из таблицы
hash_table.remove_key("apple")

# Проверяем, что ключ больше не существует
value = hash_table.get_value("apple")
print(f"Значение для ключа 'apple' после удаления: {value}")

# Проверка автоувеличения таблицы:
fruits_list = ['banana', 'orange', 'strawberry', 'pineapple', 'mango', 'grape', 'kiwi', 'peach', 'cherry', 'lemon',
               'blueberry', 'raspberry', 'plum', 'papaya', 'avocado']
for i, item in enumerate(fruits_list, 1):
    hash_table.put_key_and_value(item, i)

# Выводим содержимое хэш-таблицы
print("Содержимое хэш-таблицы:")
print(hash_table)


# 11. Реализуем структуру бинарного дерева.
# 12. Для бинарного дерева характерно наличие двух потомков, где левый меньше родителя, а правый – больше.
# 13. Для реализации можно использовать как и простое числовое дерево, так и обобщенный тип. Учитывая, что мы строим
# именно бинарное дерево, то при использовании обобщенных типов убедитесь, что значение поддерживает сравнение
# (интерфейс Comparable)
# 14. Реализуем алгоритм поиска элементов по дереву (поиск в глубину).
# 15. Для работы с бинарным деревом необходимо как минимум организовать метод поиска.


class TreeNode:
    """
    Этот класс представляет узел бинарного дерева и имеет атрибуты: значение, хранимое в узле (тип данных int);
    ссылку на левое поддерево (узел или None); ссылку на правое поддерево (узел или None).
    """
    def __init__(self, value):
        if not isinstance(value, int):
            raise ValueError('Значение для добавления в бинарное дерево должно быть целочисленным')

        self.value = value
        self.left = None
        self.right = None


class BinaryTree:
    """
    Этот класс представляет реализацию бинарного дерева.
    """
    def __init__(self):
        self.root = None

    def insert(self, value):
        """
        Метод вставляет элемент с заданным значением в бинарное дерево.

        :param value: Значение элемента для вставки.
        """
        # Вспомогательная функция для рекурсивной вставки элемента:
        def _insert_recursive(node, value):
            """
            Вспомогательная функция для рекурсивной вставки элемента в дерево.

            :param node: Текущий узел для рассмотрения.
            :param value: Значение элемента для вставки.
            :return: Узел, который был вставлен.
            """
            if not node:
                return TreeNode(value)
            if value < node.value:
                node.left = _insert_recursive(node.left, value)
            elif value > node.value:
                node.right = _insert_recursive(node.right, value)
            return node

        self.root = _insert_recursive(self.root, value)

    def search(self, value):
        """
        Ищет элемент с заданным значением в бинарном дереве.

        :param value: Значение элемента для поиска.
        :return: Узел с заданным значением, если есть, иначе None.
        """
        # Вспомогательная функция для поиска элемента:
        def _search_recursive(node, value):
            """
            Вспомогательная функция для рекурсивного поиска элемента в дереве.

            :param node: Текущий узел для рассмотрения.
            :param value: Значение элемента для поиска.
            :return: Узел с заданным значением, если есть, иначе None.
            """
            if not node or node.value == value:
                return node
            if value < node.value:
                return _search_recursive(node.left, value)
            return _search_recursive(node.right, value)

        return _search_recursive(self.root, value)

    def traverse_inorder(self):
        """
        Выполняет обход бинарного дерева в порядке in-order и выводит на экран значение каждого узла.
        """
        # Вспомогательная функция для рекурсивного обхода дерева (in-order):
        def _traverse_inorder(node):
            """
            Вспомогательная функция для рекурсивного обхода дерева в порядке in-order.

            :param node: Текущий узел для рассмотрения.
            """
            if node:
                _traverse_inorder(node.left)
                print(node.value)  # Здесь можно выполнить нужное действие с элементом, например, добавить его в список.
                _traverse_inorder(node.right)

        _traverse_inorder(self.root)


# Пример использования.
binary_tree = BinaryTree()

# Вставка элемента в бинарное дерево:
binary_tree.insert(10)
binary_tree.insert(5)
binary_tree.insert(15)
binary_tree.insert(3)
binary_tree.insert(7)

# Поиск элемента в дереве:
find_node = binary_tree.search(7)
if find_node:
    print(f'Элемент {find_node.value} найден')
else:
    print('Элемента в дереве нет')

# Обход дерева в порядке in-order и выводим значения в порядке возрастания на экран:
print('Обход дерева:')
binary_tree.traverse_inorder()

# ----------------------------------------------------------------------------------------------------------------------
# Домашнее задание:

# Необходимо превратить собранное на семинаре дерево поиска в полноценное левостороннее красно-черное дерево, а также
# реализовать в нем метод добавления новых элементов с балансировкой.
# Красно-черное дерево имеет следующие критерии:
# ● Каждая нода имеет цвет (красный или черный);
# ● Корень дерева всегда черный;
# ● Новая нода всегда красная;
# ● Красные ноды могут быть только левым ребенком;
# ● У красной ноды все дети черного цвета.
# Соответственно, чтобы данные условия выполнялись, после добавления элемента в дерево необходимо произвести
# балансировку, благодаря которой все критерии выше станут валидными.
# Для балансировки существует 3 операции – левый малый поворот, правый малый поворот и смена цвета.
# Критерии применения операций по смене цвета, левому и правому повороту следующие:
# ● Если правый ребенок – красный, а левый - черный, то применяем правый поворот;
# ● Если левый ребенок красный и его левый ребенок тоже красный – применяем левый поворот;
# ● Если оба ребенка красные – делаем смену цвета;
# ● Если корень стал красным – просто перекрашиваем его в черный.


class RedBlackNode:
    """
    Класс представляет узел, который используется в красно-черном дереве. Каждый узел содержит значение, тип данных int;
    указатели на левого и правого потомка; цвет, который может быть либо красным, либо черным.
    """
    def __init__(self, value):
        if not isinstance(value, int):
            raise ValueError('Значение для добавления в красно-чёрное дерево должно быть целочисленным')

        self.value = value
        self.left = None
        self.right = None
        self.color = 'RED'  # Новые узлы всегда красные


class RedBlackTree:
    """
    Класс реализует красно-черное дерево. Это структуры данных, которая обеспечивает эффективную вставку, поиск и
    удаление элементов, поддерживая балансировку для обеспечения оптимальной производительности.
    """
    def __init__(self):
        self.root = None  # Корневой узел, изначально None

    def insert_with_balance(self, value):  # Вставка узла как в обычное бинарное дерево поиска.
        """
        Добавляет новый элемент с заданным значением в дерево и выполняет балансировку.

        :param value: Значение, которое требуется добавить в красно-чёрное дерево.
        :return: Сбалансированное дерево.
        """
        # Вспомогательная функция для рекурсивной вставки элемента:
        def _insert_recursive(node, value):
            """
            Внутренний метод для рекурсивной вставки элемента в дерево.

            :param node: Текущий узел, в который выполняется вставка.
            :param value: Значение, которое будет вставлено.
            :return: Узел с добавленным значением и выполненной балансировкой.
            """
            if not node:
                return RedBlackNode(value)

            if value < node.value:
                node.left = _insert_recursive(node.left, value)
            elif value > node.value:
                node.right = _insert_recursive(node.right, value)

            # После вставки, выполняем балансировку.
            return self._balance(node)

        self.root = _insert_recursive(self.root, value)

    def search(self, value):
        """
        Ищет элемент с заданным значением в красно-черном дереве.

        :param value: Значение, которое необходимо найти.
        :return: Узел с заданным значением, если найден, иначе None.
        """
        # Вспомогательная функция для поиска элемента:
        def _search_recursive(node, value):
            """
            Внутренний метод для рекурсивного поиска элемента в дереве.

            :param node: Текущий узел, с которого начинается поиск.
            :param value: Значение, которое необходимо найти.
            :return: Узел с заданным значением, если найден, иначе None.
            """
            if not node or node.value == value:
                return node
            if value < node.value:
                return _search_recursive(node.left, value)
            return _search_recursive(node.right, value)

        return _search_recursive(self.root, value)

    def traverse_inorder(self):
        """
        Выполняет рекурсивный обход красно-черного дерева в порядке "in-order" (левый узел, текущий узел, правый узел)
        и выводит значения узлов на экран.
        """
        # Вспомогательная функция для рекурсивного обхода дерева (in-order):
        def _traverse_inorder(node):
            """
            Внутренний метод для рекурсивного обхода дерева в порядке "in-order" и вывода значений на экран.

            :param node: Текущий узел, с которого начинается обход.
            """
            if node:
                _traverse_inorder(node.left)
                print(node.value)
                _traverse_inorder(node.right)

        _traverse_inorder(self.root)

    def _balance(self, node):
        """
        Выполняет балансировку красно-черного дерева, проверяя и исправляя нарушения красно-черных свойств.

        :param node: Текущий узел, с которого начинается балансировка.
        :return: Узел с выполненной балансировкой.
        """
        # Проверка нарушения красно-черных свойств
        if not node:
            return node

        # Проверка наличия красных детей
        if self._is_red(node.left) and self._is_red(node.left.left):
            node = self._rotate_right(node)

        if self._is_red(node.right):
            node = self._rotate_left(node)

        if self._is_red(node.left) and self._is_red(node.right):
            self._flip_colors(node)

        return node

    def _is_red(self, node):
        """
        Проверяет, является ли узел красным.

        :param node: Узел, цвет которого проверяется.
        :return: True, если узел красный, иначе False.
        """
        if not node:
            return False
        return node.color == "RED"

    def _rotate_left(self, node):
        """
        Выполняет левое вращение поддерева с указанным узлом.

        :param node: Узел, относительно которого выполняется левое вращение.
        :return: Новый корневой узел после левого вращения.
        """
        new_root = node.right
        node.right = new_root.left
        new_root.left = node
        new_root.color = node.color
        node.color = "RED"
        return new_root

    def _rotate_right(self, node):
        """
        Выполняет правое вращение поддерева с указанным узлом.

        :param node: Узел, относительно которого выполняется правое вращение.
        :return: Новый корневой узел после правого вращения.
        """
        new_root = node.left
        node.left = new_root.right
        new_root.right = node
        new_root.color = node.color
        node.color = "RED"
        return new_root

    def _flip_colors(self, node):
        """
        Инвертирует цвета узлов: узел становится красным, а его левый и правый потомки становятся черными.

        :param node: Узел, у которого меняются цвета.
        """
        node.color = "RED"
        node.left.color = "BLACK"
        node.right.color = "BLACK"


# Пример использования.
red_black_tree = RedBlackTree()

# Вставляем элементы с балансировкой:
red_black_tree.insert_with_balance(10)
red_black_tree.insert_with_balance(20)
red_black_tree.insert_with_balance(5)
red_black_tree.insert_with_balance(15)

# Ищем элемент в дереве:
result_node = red_black_tree.search(20)
if result_node:
    print(f'Элемент {result_node.value} найден')
else:
    print('Элемента нет')

# Выполняем in-order обход дерева и выводим элементы в порядке возрастания.
red_black_tree.traverse_inorder()
