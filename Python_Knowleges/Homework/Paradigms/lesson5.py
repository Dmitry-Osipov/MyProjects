# Задача 1: Напишите программу, которая находит все простые числа в заданном диапазоне.
# Простые числа - это числа больше 1, которые не имеют делителей, кроме 1 и самих себя. Задача состоит в том, чтобы
# написать программу, которая будет находить и выводить все простые числа в заданном диапазоне.
# Пример решения:
# Программа принимает на вход начальное и конечное числа диапазона.
# Для каждого числа в диапазоне проверяется, является ли оно простым.
# Если число простое, оно добавляется в список простых чисел.
# В конце программа выводит список найденных простых чисел.


def is_prime(number: int, divisor: int = 2) -> bool:
    """
    Функция проверяет, является ли число простым.
    :param number: Целое число, которое нужно проверить.
    :param divisor: Целое число - делитель, по умолчанию принимает значение 2.
    :return: Булева-значение.
    """
    if not isinstance(number, int):
        number = int(number)

    if not isinstance(divisor, int):
        divisor = int(divisor)

    if number < 2:
        return False
    if number == 2:
        return True
    if number % divisor == 0:
        return False
    if divisor * divisor > number:
        return True
    return is_prime(number, divisor + 1)


user_end = int(input('Input the number that ends our list: '))
if user_end <= 1:
    raise ValueError('Your number cannot be less than 2')

prime_numbers = []
for number in range(1, user_end + 1):
    if is_prime(number):
        prime_numbers.append(number)

print(prime_numbers)

# Задача 2: Напишите программу, которая сортирует список чисел методом сортировки слиянием.
# Сортировка слиянием - это эффективный алгоритм сортировки, который разбивает список на две половины, сортирует их
# отдельно, а затем объединяет в отсортированный список. Задача состоит в том, чтобы написать программу, которая будет
# сортировать список чисел методом сортировки слиянием.
# Пример решения:
# Программа принимает на вход список чисел, который нужно отсортировать.
# Если список состоит из одного элемента или пуст, он считается уже отсортированным.
# В противном случае список разделяется на две половины.
# Рекурсивно вызывается сортировка слиянием для каждой половины.
# Затем отсортированные половины сливаются в один отсортированный список.
# Конечный отсортированный список возвращается.


def merge_sort(numbers: list[int]) -> list:
    """
    Функция по реализации алгоритма сортировки слиянием.
    :param numbers: Список чисел, который нужно отсортировать.
    :return: Отсортированный по не убыванию список чисел.
    """
    if not isinstance(numbers, list):
        numbers = list(numbers)

    length = len(numbers)
    if length <= 1:
        return numbers

    middle = length // 2
    left_half = numbers[:middle]
    right_half = numbers[middle:]

    left_half = merge_sort(left_half)
    right_half = merge_sort(right_half)

    return _merge(left_half, right_half)


def _merge(left: list, right: list) -> list:
    """
    Вспомогательная функция для merge_sort, соединяет 2 списка.
    :param left: Список чисел.
    :param right: Список чисел.
    :return: Соединённый список чисел.
    """
    result = []
    i, j = 0, 0

    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])

    return result


some_numbers = [1, 5, 7, 9, 0, 3, 2, 4, 6, 3, 2, 1, 0, 4, 7]
print(merge_sort(some_numbers))

# Задача 3:Сложная задача: По желанию.
# Задача: НОП (наибольшая общая подпоследовательность) двух строк — это самая длинная последовательность символов,
# которая содержится и в первой, и во второй строке, в том же порядке, но не обязательно подряд. Другими словами, это
# максимально длинная последовательность символов, которая является "общей" для обеих строк.
# Пример:
# X = "AGGTAB"
# Y = "GXTXAYB"
# Наибольшая общая подпоследовательность: "GTAB" (другие НОП также могут быть "GTTAB" и "GTXAB").
# Задача состоит в том, чтобы написать программу, которая находит НОП для двух заданных строк.
# Примечание: Все задачи представляют решения в логической парадигме, где алгоритмы и логика играют ключевую роль.


def longest_common_subsequence(x: str, y: str) -> str:
    """
    Функция реализует алгоритм LCS с использованием динамического программирования. Функция ищет наибольшую общую
    последовательность для двух строк: алгоритм создает и заполняет матрицу dp для определения длины наибольшей общей
    подпоследовательности, а затем восстанавливает саму подпоследовательность из матрицы.
    :param x: Первая строка.
    :param y: Вторая строка.
    :return: Строку с наибольшей общей последовательность двух строк.
    """
    x_len, y_len = len(x), len(y)
    # Создание матрицы для хранения результатов
    dp = [[0] * (y_len + 1) for _ in range(x_len + 1)]

    # Заполнение матрицы
    for i in range(x_len):
        for j in range(y_len):

            # Внутри вложенных циклов мы сравниваем символы x[i] и y[j]. Если символы совпадают, мы увеличиваем значение
            # dp[i + 1][j + 1] на 1 относительно значения dp[i][j], что говорит о том, что длина наибольшей общей
            # подпоследовательности увеличивается.
            if x[i] == y[j]:
                dp[i + 1][j + 1] = dp[i][j] + 1

            # Если символы не совпадают, мы выбираем максимальное значение между dp[i][j + 1] (символ из строки 'x'
            # добавлен в LCS) и dp[i + 1][j] (символ из строки 'y' добавлен в LCS), и записываем это значение в
            # dp[i + 1][j + 1]. Это говорит о том, что мы используем максимальную длину наибольшей общей
            # подпоследовательности из двух предыдущих состояний.
            else:
                dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j])

    # После заполнения матрицы dp, начинаем восстанавливать наибольшую общую подпоследовательность.
    # Используем переменные i и j, начиная с конца строк 'x' и 'y'.
    lcs = []
    i, j = x_len, y_len
    while i > 0 and j > 0:

        # Если символы X[i-1] и Y[j-1] совпадают, добавляем текущий символ X[i-1] в список lcs
        # (наибольшая общая подпоследовательность), затем декрементируем i и j.
        if x[i - 1] == y[j - 1]:
            lcs.append(x[i - 1])
            i -= 1
            j -= 1

        # Если символы не совпадают, мы выбираем максимальное значение между dp[i-1][j] и dp[i][j-1], чтобы определить,
        # по какому направлению двигаться (вверх или влево). Если значение dp[i-1][j] больше, декрементируем i,
        # иначе декрементируем j.
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1

    lcs.reverse()
    return ''.join(lcs)


X = "AGGTAB"
Y = "GXTXAYB"
print(longest_common_subsequence(X, Y))
