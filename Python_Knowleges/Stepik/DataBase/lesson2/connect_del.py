"""
Рассмотрим, как из программы на Python осуществляется связь с СУБД SQLite. Импортируем модуль sqlite3 и переименуем его
для удобства дальнейшего использования.
"""

import sqlite3 as sq

con = sq.connect("saper.db")
cur = con.cursor()
cur.execute("""""")
""" 
Вызываем метод connect, который устанавливает связь с saper.db базой данных. Этот файл должен находиться в том же 
каталоге, что и исполняемый файл на питоне. Если он там есть, то связь с БД будет установлена, а если нет, то он будет 
создан.

Для непосредственного взаимодействия с БД, мы должны использовать объект cursor (ссылаемся на него отдельной переменной
cur). Т.е. метод cursor возвращает экземпляр класса Cursor, и уже через него мы осуществляем непосредственную работу. 
В самом простом случае можем вызвать метод execute(), которому передаётся SQL-запрос для работы с БД. В нашем варианте 
запроса нет, там пустая строка, но это тоже рабочая программа.
 
После того, как мы поработали с БД, её нужно обязательно закрыть. Для чего нужно вызвать метод close() у объекта
connect, на который ссылается переменная con. 
"""

con.close()

"""
После выполнения программы, мы видим, что ошибок нет. Также в одном пакете с исполняемым файлом появился файл saper.db, 
который и представляет собой хранилище - базу данных.

Причём в качестве расширения для таких файлов ставят обычно: *.db, *.db3, *.sqlite, *.sqlite3. Конечно, можно писать 
произвольное расширение, но принято писать одно из этих четырёх.

Сразу отметим, что использование в таком виде, как у нас выше, соединение с БД, не является самым лучшим вариантом, ибо 
если в строчках программы произойдёт какая-либо ошибка, то метод close() не выполнится, что грозит нам возможной потерей
данных, так что открывать БД лучше через контекст-менеджера:
"""

with sq.connect("saper.db") as con:
    cur = con.cursor()
    cur.execute("""""")

"""
Теперь контекст-менеджер сам закрывает БД даже при исключении. Такая конструкция является более удобной и безопасной в 
использовании. Далее перейдём в программу и откроем нашу БД из того каталога, где она была создана.

Открыв её, мы видим, что наша БД не содержит таблиц, индексов, представлений и тригеров. В целом, так и должно быть. Мы 
просто создали хранилище, но пока туда ничего не поместили. Далее нам необходимо создать таблицы, чтобы хранить там 
какие-либо данные.

Создадим такую таблицу:
name - строка с именем игрока;
sex - число, пол игрока (1 - мужской, 2 - женский);
old - число, возраст игрока;
score - суммарное число набранных очков за все игры.

Типы данных (типы полей):
NULL - значение NULL;
INTEGER - целочисленный тип данных (занимает от 1 до 8 байт);
REAL - вещественный тип (8 байт в формате IEEE);
TEXT - строковый тип (в кодировке данных базы, обычно UTF-8);
BLOB - (в двоичные данные, хранятся "как есть", например, для небольших изображений).

Для создания таблицы с нужной структурой, пропишем в методе execute следующее:
"""

# with sq.connect("saper.db") as con:
#     cur = con.cursor()
#     cur.execute("""CREATE TABLE users (
#     name TEXT,
#     sex INTEGER,
#     old INTEGER,
#     score INTEGER
#     )""")

"""
Т.е. мы говорим создать таблицу *имя*, а далее указываем, какая структура будет у этой таблицы, т.е. набор полей с типом
данных.
Исполним код и проверим изменения. Чтобы увидеть изменения в программе с БД требуется переоткрыть БД.

Возвращаясь к SQL-запросу: его команды принято писать заглавными буквами, а названия таблиц или полей - малыми, а тип
данных мы тоже указываем заглавными. В дальнейшем мы будем придерживаться этого негласного правила. Конечно, можно 
писать и малыми, и заглавными, но принято использовать заглавные буквы.

Но в таком запросе, что мы прописали выше есть недостаток: если исполнить код ещё раз, то мы получим исключение, т.к. 
мы пытаемся создать таблицу, которая уже существует, поэтому следует добавить в запрос IF NOT EXISTS:
"""

with sq.connect("saper.db") as con:
    cur = con.cursor()
    cur.execute("""CREATE TABLE IF NOT EXISTS users (
    name TEXT,
    sex INTEGER,
    old INTEGER,
    score INTEGER
    )""")

"""
Теперь при запуске программы, ошибки уже нет.

Хорошо, таблицу создали, но как ей теперь можно пользоваться?
В самом простом случае можно добавить данные прямо в эту таблицу через скаченную на прошлом уроке программу. Переходим 
на вкладку данные, чуть ниже видим список таблиц, с которыми мы работаем (т.к. таблица всего одна, то она одна и будет
отображаться). Далее правее нажимаем на кнопку добавить запись и ввести соответствующие значения. Далее нажимаем кнопку 
tab и переходим на следующую запись, если нам её нужно добавить.

После операций добавление обязательно нужно нажать "записать изменения" (справа от кнопки "открыть базу данных").

Теперь если перейти на вкладку SQL (скрин на первом уроке), то на ней можно писать различные SQL-запросы. 
Например, напишем SELECT * FROM users (выбираем все поля из таблицы users) - а далее нажимаем на кнопку исполнения под
вкладкой SQL. Соответственно, отображаются все наши записи, что мы ввели и все наши поля.

С помощью этого запроса можно показать следующее: каждая таблица в SQLite содержит скрытое поле rowid. При добавлении 
его к запросу (SELECT rowid, * FROM users) - мы увидим столбец, у которого id принимает значение согласно порядковому 
номеру строки (отсчёт начинается с 1). В действительности rowid - это уникальный идентификатор для каждой записи. Т.е. 
используя rowid, можно осуществлять связывание нескольких таблиц между собой для формирования сводного отчёта.

Теперь рассмотрим следующую команду - удаление таблицы:
"""

with sq.connect("saper.db") as con:
    cur = con.cursor()
    cur.execute("""DROP TABLE IF EXISTS users""")  # если не прописать условие, то поймаем исключение.

"""
Теперь при переоткрытии БД мы видим, что таблица была удалена.

Но вернёмся к созданию полей в таблице. При создании полей в таблице мы можем выставить ограничители. 
Например, если нам нужно, чтобы поле name никогда не было пустым, то мы можем добавить ключевые слова NOT NULL, которое 
говорит как раз о том, что поле name должно быть заполнено определёнными данными.
Или для sex можно выставить DEFAULT 1, что означает, что по умолчанию, если мы не будем передавать в поле sex какое-либо 
значение, то туда будет записано значение, равное единице, но по умолчанию для такого ограничения также ставят NOT NULL. 
Посмотрим, как отработает такой код:
"""

with sq.connect("saper.db") as con:
    cur = con.cursor()
    cur.execute("""CREATE TABLE IF NOT EXISTS users (
    name TEXT NOT NULL,
    sex INTEGER NOT NULL DEFAULT 1,
    old INTEGER,
    score INTEGER
    )""")

"""
Открываем заново БД, видим, что была создана таблица как раз с этими ограничителями. Заполним же данные в программе.
При добавлении новых строк, мы видим, что поле sex сразу указано со значением 1, а поле name содержит пустую строку (не 
NULL, а именно пустую строку).

Также в любой таблице можно создавать такие поля: 
допустим, мы хотим создать некое поле user_id, которое будет целочисленное, и далее указываем, что оно будет главным 
ключом, т.е. PRIMARY KEY. В действительности PRIMARY KEY говорит о том, что user_id должно содержать уникальные значения.

Создадим таблицу с новой структурой:
"""

with sq.connect("saper.db") as con:
    cur = con.cursor()
    cur.execute("""CREATE TABLE IF NOT EXISTS users (
    user_id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    sex INTEGER NOT NULL DEFAULT 1,
    old INTEGER,
    score INTEGER
    )""")

"""
Теперь попробуем что-то в неё добавить. При нажатии кнопки "Добавить запись", автоматически поле user_id принимает 
значение 1 (если запись первая). Далее при добавлении новой записи поле user_id меняет своё значение на 2. При попытке 
изменения user_id в момент создания новой строки, мы получим предупреждение, и не сможем этого сделать.

Но обычно при создании главного ключа прописывают свойство AUTOINCREMENT, которое говорит о том, чтобы значение поля 
user_id каждый раз увеличивалось на 1.
"""

with sq.connect("saper.db") as con:
    cur = con.cursor()
    cur.execute("""CREATE TABLE IF NOT EXISTS users (
    user_id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    sex INTEGER NOT NULL DEFAULT 1,
    old INTEGER,
    score INTEGER
    )""")

# P.s.: также было замечено, что мы словим исключение, если в БД имеются несохранённые данные, а мы пытаемся оперировать
# с БД в этот момент. Также возможно изменить поле user_id уже после создания записи.
