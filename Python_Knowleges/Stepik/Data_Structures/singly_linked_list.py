"""
Односвязный список.
Начнём с основных недостатков динамических массивов: если в нашем массиве не хватает места, то мы создаём новый массив,
в первую половину нового массива копируем весь старый массив, а во вторую можем добавлять новые значения. Это составляет
O(n). Кроме того, массив хранится в непрерывной области памяти, что является большой проблемой для огромных массивов.
Как решить эти проблемы? Что если при увеличении физического размера динамического массива мы просто выделим ещё один
такой же кусок где-то в памяти (т.е. данные не будут идти строго друг за другом, а находиться в разных областях)?
Очевидно, при таком подходе нам не придётся копировать уже имеющиеся данные в новый массив и не требуется искать всё
большую и большую область памяти. Более того, скорость добавления нового элемента составляло бы O(1). Осталось
придумать, как мы будем переходить от последнего элемента старого массива к первому элементу нового массива (напоминаю,
2 эти массива хранятся в разных участках данных). Самое просто, что можно сделать - это хранить в последнем элементе
ссылку на первый элемент следующего массива (ar = [1, 2, 3, next] -> [x, x, x, next] -> [y, y, y, next] -> и т.д.).
Таким образом, можно получить связанную структуру данных (словно паровоз). А теперь возведём такую структуру в абсолют и
вообще откажемся от массивов. Вместо них определим отдельные элементы, которые будут ссылаться друг на друга, пока
последний не будет иметь ссылку на значение None:

       |----|        |----|        |----|       |----|
       |data|     ==>|data|     ==>|data|    ==>|data|     ==> None
head = |----|   ||   |----|   ||   |----|  ||   |----|   ||
       |next|===     |next|===     |next|===    |next|===
       |----|        |----|        |----|       |----|

Такая структура данных, в которой элементы ссылаются друг на друга по порядку в одном направлении, начиная от первого,
и до последнего, получила название односвязный список.

Добавление в конец односвязного списка.
Предположим, что в списке всего 2 объекта. На первый элемент всегда ссылается переменная head, а на последний - tail.

  head         tail
   |            |
   V            V
|----|       |----|
|data|    ==>|data|     ==> None
|----|  ||   |----|   ||
|next|===    |next|===
|----|       |----|

Допустим, мы хоти добавить элемент. Для этого надо создать сам объект. На новый объект будет ссылаться временная
переменная node:

  head         tail                    node
   |            |                       |
   V            V                       V
|----|       |----|                  |----|
|data|    ==>|data|     ==> None     |data|
|----|  ||   |----|   ||             |----|
|next|===    |next|===               |next|
|----|       |----|                  |----|

Затем по ссылке tail мы выбираем последний элемент этого списка (который скоро станет предпоследним), и ссылку next мы
должны переопределить на этот новый добавляемый объект, а ссылку следующего элемента последнего объекта определить
на None. После данной операции перекидываем ссылку tail на новый последний элемент списка (раньше был node).
В результате получаем следующую связку:

  head                       tail
   |                          |
   V                          V
|----|       |----|        |----|
|data|    ==>|data|     ==>|data|     ==> None
|----|  ||   |----|   ||   |----|   ||
|next|===    |next|===     |next|===
|----|       |----|        |----|

Скорость выполнения такой операции составляет O(1). Часто в ЯП данную операцию реализуют методом push_back(). Теперь
посмотрим, как добавить элемент в начало односвязного списка. Также создаём новый объект, на который ссылается временная
переменная node:

  node         head                        tail
   |            |                           |
   V            V                           V
|----|       |----|        |----|        |----|
|data|       |data|     ==>|data|     ==>|data|     ==> None
|----|       |----|   ||   |----|   ||   |----|   ||
|next|       |next|===     |next|===     |next|===
|----|       |----|        |----|        |----|

А затем нам нужно сделать так, чтобы ссылка next у node вела на тот объект, на который сейчас ссылается
head. Т.е. мы настраиваем ту же связь, что и в примере выше, но теперь для нового узла node присваиваем переменную head.

  head                                     tail
   |                                        |
   V                                        V
|----|       |----|        |----|        |----|
|data|       |data|     ==>|data|     ==>|data|     ==> None
|----|    ==>|----|   ||   |----|   ||   |----|   ||
|next|   ||  |next|===     |next|===     |next|===
|----|===    |----|        |----|        |----|

Скорость выполнения данной операции так же составляет О(1). Часто в ЯП эту операцию реализуют методом push_front().

Теперь рассмотрим, как можно обратиться к произвольному элементу односвязного списка. Допустим, у нас есть односвязный
список из четырёх элементов. Очевидно, с помощью head.data можно получить данные первого элемента, а с помощью tail.data
можно получить данные последнего элемента:

  head                                     tail
   |                                        |
   V                                        V
|----|       |----|        |----|        |----|
|data|       |data|     ==>|data|     ==>|data|     ==> None
|----|    ==>|----|   ||   |----|   ||   |----|   ||
|next|   ||  |next|===     |next|===     |next|===
|----|===    |----|        |----|        |----|

Но что если мы хотим обратиться ко второму или третьему элементу нашего списка? Мы создаём временный указатель node,
далее мы хотим обратиться к следующему элементу, но на следующий элемент ведёт указатель next. Причём эта next находится
в текущем объекте:

  head                                     tail
   |                                        |
   V                                        V
|----|       |----|        |----|        |----|
|data|       |data|     ==>|data|     ==>|data|     ==> None
|----|    ==>|----|   ||   |----|   ||   |----|   ||
|next|   ||  |next|===     |next|===     |next|===
|----|===    |----|        |----|        |----|
  ^
  |
 node

Значит, для перехода к следующему элементу на уровне псевдокода мы должны выполнить операцию node = node.next, т.е.
ссылке node присвоить адрес следующего объекта, а адрес следующего объекта находится в ссылке next у текущего объекта.
В результате выполнения этой команды у нас указатель node переходит к следующему элементу:

  head                                     tail
   |                                        |
   V                                        V
|----|       |----|        |----|        |----|
|data|       |data|     ==>|data|     ==>|data|     ==> None
|----|    ==>|----|   ||   |----|   ||   |----|   ||
|next|   ||  |next|===     |next|===     |next|===
|----|===    |----|        |----|        |----|
               ^
               |
              node

Доступ к односвязному списку.
Далее выполняя такую команду по циклу, мы можем пройтись по всем элементам этого односвязного списка до тех пор, пока не
дойдём до tail, у которого ссылка next принимает значение None. Т.е. если мы хотим получить доступ к произвольному
элементу, то мы должны с самого начала перебрать все предыдущие элементы, пока не окажемся в месте нужного элемента.
Сложность поиска в односвязном списке O(n).

Вставка в произвольное место:
Для вставки элемента в односвязный список, нам требуется определиться с позицией. Допустим, нам надо вставить между 2 и
3 элементами. Тогда 2 элемент мы обозначаем ссылкой left, 3 элемент обозначаем ссылкой right, а на новый элемент ставим
ссылку node. Далее мы перенастраиваем ссылки: left.next = node (теперь ссылка next левого элемента указывает на новый
элемент), node.next = right (теперь ссылка next нового элемента ссылается на правый элемент). Обычно, это действие в ЯП
реализуется методом insert(). Сложность O(n) - ибо поиск места O(n) + вставка элемента O(1).

Удаление промежуточных элементов.
Возьмём примером тот же список из 5 элементов: находим left, right и node, меняем ссылку left, а ссылку на node просто
удаляем. На уровне псевдокода это выглядит так: left.next = right. Скорость операции O(n), ибо для поиска ссылок
left и right требуется O(n) + само удаление элемента O(1). Обычно в ЯП реализуется методом erase().

Удаление первого элемента.
Достаточно простое удаление: нам требуется перенести ссылку head на следующий элемент, этим удаляя прошлый элемент.
Скорость операции O(1), реализуется обычно с помощью метода pop_front(). На уровне псевдокода: head = head.next.

Удаление последнего элемента.
При удалении последнего элемента в списке нам необходимо сначала получить ссылку на предпоследний элемент, затем
освободить память, которую занимает последний элемент, затем изменить значение tail, и заменить значение ссылки node 
на None. На уровне псевдокода tail = node -> node.next = None. Скорость удаления последнего элемента O(n) - поиск
предпоследнего элемента O(n) + удаление O(1). В ЯП такая операция часто реализуется методом pop_back().

Итоги теории:
|=========================================================|
| Название                         | Команда      | Big O |
|=========================================================|
| Добавление в конец               | push_back()  | O(1)  |
|---------------------------------------------------------|
| Добавление в начало              | push_front() | O(1)  |
|---------------------------------------------------------|
| Удаление с конца                 | pop_back()   | O(1)  |
|---------------------------------------------------------|
| Удаление с начала                | pop_front()  | O(1)  |
|---------------------------------------------------------|
| Вставка элемента                 | insert()     | O(n)  |
|---------------------------------------------------------|
| Удаление промежуточных элементов | erase()      | O(n)  |
|---------------------------------------------------------|
| Доступ к элементу                | iterator()   | O(n)  |
|=========================================================|
"""


class Node:
    def __init__(self, value):
        self.value = value
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def is_empty(self):
        return self.head is not None

    def push_front(self, value):
        new_node = Node(value)
        new_node.next = self.head
        self.head = new_node

    def pop_front(self):
        if self.is_empty():
            self.head = self.head.next

    def iterator(self, value):
        current_node = self.head
        while current_node:
            if current_node.value == value:
                return True
            current_node = current_node.next

        return False

    def push_back(self, value):
        current_node = self.head
        new_node = Node(value)
        while current_node:
            if current_node.next is None:
                current_node.next = new_node
                break
            current_node = current_node.next

    def pop_back(self):
        current_node = self.head
        if self.is_empty():
            while current_node.next:
                if current_node.next.next is None:
                    current_node.next = None
                    return
                current_node = current_node.next
            self.head = None

    def print_list(self):
        temp_node = self.head
        while temp_node:
            print(temp_node.value, end=' ')
            temp_node = temp_node.next
        print()


linked_list = LinkedList()
linked_list.push_front(1)  # 1
linked_list.push_front(3)  # 3 1
linked_list.push_front(8)  # 8 3 1
linked_list.push_back(5)  # 3 1 5
linked_list.push_back(10)  # 3 1 5 10
linked_list.pop_back()  # 8 3 1 5
print(linked_list.iterator(3))  # True
linked_list.pop_front()  # 3 1 5
linked_list.print_list()  # Вывод всех значений списка
