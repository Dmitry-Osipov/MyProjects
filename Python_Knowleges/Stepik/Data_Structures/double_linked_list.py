"""
Двусвязный список - это тот же односвязный список, но у каждого элемента есть 2 ссылки next и prev (на следующий и
прошлый элементы соответственно).

                head                                                    tail
                 |                                                       |
                 V                                                       V
            |---------|       |---------|        |---------|        |---------|
None <==    |  data   |<== ==>|  data   |<==  ==>|  data   |<==  ==>|  data   |     ==> None
       ||   |---------|  ||   |---------|   ||   |---------|   ||   |---------|   ||
         ===|prev-next|=== ===|prev-next|===  ===|prev-next|===  ===|prev-next|===
            |---------|       |---------|        |---------|        |---------|

Также имеем 2 элемента списка: head и tail, которые ссылаются на первый и последний элементы соответственно.
В результате можно быстро обрабатывать элементы. Например, делать добавление элементов в начало или конец списка, а
также удалять их. Важно обратить внимание, что у граничных объектов next и prev принимают значение None:
для head.prev = None (ибо это первый элемент списка, раньше него ничего стоять не может) и для tail.next = None (ибо это
последний элемент списка, после него ничего стоять не может).

Добавление в конец списка.
Меняем ссылку tail.next на наш новый элемент (пусть node), и вместе с тем меняем ссылку node.prev на наш хвост, после
чего двигаем указатель tail на наш новы последний элемент списка. На псевдокоде: tail.next = node -> node.prev = tail ->
tail = node. Сложность данной операции О(1). Реализуется командой push_back().

Добавление в начало списка.
По аналогии реализуется добавление в начало списка. Меняем ссылку head.prev на новый элемент (пусть node), и вместе с
тем меняем ссылку node.next на нашу голову, после чего двигаем указатель head на наш новый первый элемент.
На псевдокоде: head.prev = node -> node.next = head -> head = node. Скорость работы этой операции так же O(1).
Реализуется командой push_front().

Доступ к произвольному элементу.
Допустим, есть список, в котором мы знаем только head и tail. Создадим временную переменную node, которая указывает на
head. Благодаря временной переменной мы можем читать данные в списке (на псевдокоде - value = node.data) и переходить к
следующему элементу (на псевдокоде - node = node.next). Таким образом в цикле мы можем проходить по элементам. Чтобы
изменить значение в нужном элементе нужно перезаписать его (на псевдокоде - node.data = value). Сложность операции
доступа к элементу в середине списка - O(n).

Важной отличительной особенностью двусвязного списка является то, что мы можем двигаться по нему как вперёд, так и
назад: node = node.next - для движения вперёд - и node = node.prev - для движения назад. Во всём остальном они работаю
в принципе одинаково.

Вставка элемента в произвольную позицию двусвязного списка.
Создаём новый элемент с временной переменной node. Находим нужный элемент слева и справа, указываем ссылки на них
(left и right соответственно). Далее связываем с нашим node элемент слева (left.next = node -> node.prev = left) и
элемент справа (right.prev = node -> node.next = right). Сложность данной операции O(n) - вставка О(1) + нахождение left
и right O(n). Реализуется командой insert().

Удаление промежуточных элементов.
Находим нужный элемент. Указываем его как node. Далее присваиваем переменные слева и справа от него (left = node.prev и
right = node.next). После чего освобождаем память, занимаемое объектом node, настраивая связи между left и right
(left.next = right -> right.prev = left). Удаление занимает O(n), ибо получение элемента O(n) + само удаление O(1). Сама
функция реализуется через erase().

Удаление первого элемента.
Устанавливаем ссылку на следующий элемент от head (пусть node), т.е. node = head.next. Убираем ссылку на head у нашего
node (node.prev = None), после чего переносим ссылку head на новое начало (head = node). Сложность операции O(1).
Реализуется методом pop_front().

Удаление последнего элемента.
Удаление последнего элемента происходит примерно так же. Устанавливаем ссылку на элемент, который предшествует
последнему (node = tail.prev). Далее убираем ссылку на tail у нашего node (node.next = None). И в конце переносим
указатель tail на наш node (tail = node). Сложность операции O(1). Реализуется командой pop_back().

Итоги теории:
|=========================================================|
| Название                         | Команда      | Big O |
|=========================================================|
| Добавление в конец               | push_back()  | O(1)  |
|---------------------------------------------------------|
| Добавление в начало              | push_front() | O(1)  |
|---------------------------------------------------------|
| Удаление с конца                 | pop_back()   | O(1)  |
|---------------------------------------------------------|
| Удаление с начала                | pop_front()  | O(1)  |
|---------------------------------------------------------|
| Вставка элемента                 | insert()     | O(n)  |
|---------------------------------------------------------|
| Удаление промежуточных элементов | erase()      | O(n)  |
|---------------------------------------------------------|
| Доступ к элементу                | at()         | O(n)  |
|=========================================================|
"""

# TODO: написать реализацию двусвязного списка кодом. Код взять из прошлых уроков.
