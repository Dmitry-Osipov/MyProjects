"""
Как известно, статические массивы не всегда удобны, ибо требуют заранее знать память, которая требуется для массива, что
не всегда можно адекватно определить. Для избежания таких проблем появился динамический массив. Динамический массив -
это массив данных, но который может расширяться или уменьшаться сам в зависимости от операции с ним. Пример: допустим,
мы просматриваем файловую систему и сохраняем имена файлов в каждом каталоге. Очевидно, что число файлов может
варьироваться. Если пользоваться статическим массивом, то потребуется задавать размер массива очень большим, что съест
лишнюю память. Выходом будет создание динамического массива. К примеру, создаём динамический массив на 100 элементов.
Если потребуется больше места, то размер этого массива можно будет увеличить.
Рассмотрим базовый пример динамического массива: 1, 2, 3, 4, 5, x, x, x - логическим размером является размер,
по которому есть значения (для нашего примера в ячейках с цифрами от 1 до 5), а физическим размером - весь его размер
(т.е. для нашего примера все цифры + все пустые значения в виде x). Вынесем их в отдельные переменные:
currentLength = 5;
maxCapacity = 8, из которых currentLength содержит индекс следующего добавляемого в массив значения (для нашего примера
первая x, или сразу ячейка сразу после 5), а также currentLength определяет число уже записанных данных. А maxCapacity
равна максимальному числу переменных, которая имеет массив (в нашем случае 8). Т.к. данные в массиве должны храниться
последовательно, то новые добавляемые данные должны храниться в ячейке currentLength: arr[currentLength] = 6 ->
arr = [1, 2, 3, 4, 5, 6, x, x] -> currentLength += 1 - теперь currentLength указывает на элемент после 6. С точки зрения
О большого скорость данной операции - О(1) при добавлении в конец. А если нужно вставить в середину? Всё будет так же,
как в статическом массиве: сдвигаем все числа до нужного индекса, вставляем значение, увеличиваем счётчик currentLength.
И для данной операции с точки зрения О большого - O(n), где n - это размер массива.
Но следующим вопросом идёт: что делать, если массив уже заполнен, а нам надо вставить ещё 1 элемент? Выделяется память
под новый статический массив длиной в 2 или 3 раза больше первоначального (т.е. maxCapacity = maxCapacity * 2). В новый
массив копируем все прежние значения и записываем новые значения по индексу currentLength = currentLength + 1. Просто
выделить следующую ячейку в памяти и записать туда значение нельзя, ибо эта ячейка может использоваться для какого-то
другого процесса, поэтому и идём таким более сложным, но надёжным путём. Сложность операции по добавлению значения с
увеличением массива - O(n), где n - это физический размер динамического массива.
Последнее - это удаление значения из массива. Тут всё проще, ибо физический размер массива при этом не меняется.
Работает всё абсолютно так же, как и со статическими массивами: переменную currentLength уменьшаем на единицу, и тогда
наш динамический массив не берёт последнюю ячейку в памяти (ибо наш массив доходит до currentLength без учёта значения,
на которое она указывает). С точки зрения О большого удаление последнего элемента массива - это O(1).
При удалении элемента из середины массива - нам нужно сместить влево на один все элементы, стоящие правее удалённого
элемента, и также сдвинут переменную currentLength. Сложность при удалении промежуточных значений - О(n). Ещё раз
отметим, что при удалении значений физический размер не меняется, даже если ранее он увеличивался.

Итоги теории:
Динамический массив - это массив, который может менять число своих элементов в процессе работы программы.
Динамические реализуются на основе обычных статических массивов и хранят данные в непрерывной области памяти. Операции
доступа выполняются за О(1).
Если начального физического размера динамического массива недостаточно, то создаётся новый массив размером в несколько
раз больше предыдущего с копированием всех прежних значений. Часто делают удвоение размеров.
Вычислительная сложность операций вставки/удаления составляет O(n), где n - общий размер динамического массива.

Увидим на практике:
"""

marks = [2, 2, 3, 4]  # Получили список (динамический массив) на уровне языка Python.

lst = [True, '123', 123, 123.123]  # Записали разные типы данных в список. Можно ли считать такой список динамическим
# массивом? Грубо говоря, это максимально приближенная конструкция к динамическому массиву (массив должен содержать одни
# типы данных во всех ячейках).

"""
Но если окунуться на уровень глубже, то мы увидим, что динамический массив состоит из ссылок:
lst = link_1, link_2, link_3, link_4
        ^        ^       ^      ^
       True    '123'    123   123.123

Отсюда и получается эффект: словно список содержит разные типы данных. На самом деле в них хранятся только ссылки, 
ведущие на те или иные объекты, и не более того. Т.е. сам динамический массив содержит данные только одного типа: ссылки
на объекты.
"""

print(len(lst))  # Число хранимых данных можно определить такой функцией.
marks.append(5)  # Если требуется добавить значение в конец списка, то есть функция append. Сложность O(1).
print(marks)  # В деталях всё описано выше, но меняется лишь то, что мы в массив вносим не значение, а ссылку.
marks.insert(2, 3)  # Если требуется вставить значение по индексу, то используем метод insert. Сложность
# для данной операции O(n). Как видим, скорости диаметрально противоположные, так что вставок в середину/начало стоит
# избегать, а вместо них использовать добавление в конец.
print(marks)  # Опять же, всё описано в теории выше.

el_3 = marks[2]  # Обращение по индексу занимает O(1), ибо мы знаем, что где находится в памяти, так что сразу достаём
# значение по нужному индексу.
marks[0] = 3  # Замена значения по индексу так же занимает O(1).
print(el_3, marks)

print(marks + lst)  # Получили объединения списков через оператор конкатенации. По факту под капотом создаётся новый
# динамический массив, куда копируется сначала первый список, а потом и второй. Сложность O(n + m) - где n - длина
# первого, а m - длина второго списка.

"""
Что происходит при срезах списков? 
lst = [1, 2, 3, 4, 5, 6, 7, 8]
lst_2 = lst[1:6]
В операции выше мы копируем массив (срез массива даёт её копию по определённым элементам), создаём новый массив нужного 
размера, а далее в новый массив копируются соответствующие значения. Сложность операции O(n).
"""
