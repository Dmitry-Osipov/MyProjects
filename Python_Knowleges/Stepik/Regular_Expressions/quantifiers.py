import re

"""
Квантификаторы записываются как {m,n} (ВАЖНО: пробела между m и n нет!), где m - минимальное число совпадений с 
выражением, n - максимальное число совпадений с выражением. Рассмотрим на простом примере:
"""

text = "Google, Gooogle, Goooooogle"
match = re.findall(r"o{2,5}", text)
print(match)  # Во втором слове он берёт не 2 буквы о, а сразу 3, ибо квантификатор старается найти наиболее длинную
# последовательность. Если же букв больше, чем n (третье слово), то он обрежет последовательность.

"""
Квантификатор выше называют мажорным, жадным, но также есть и минорные. Для перевода квантификатора в этот режим следует 
написать знак вопроса:
"""

match = re.findall(r"o{2,5}?", text)
print(match)  # Теперь мы получили комбинации из двух букв по всем о (первые 2 буквы от первого слова, вторые от второго
# и далее все оставшиеся буквы были взяты от последнего слова.

"""
Краткие формы записи квантификаторов: 
{m} - повторение выражения ровно m раз (эквивалент {m,n});
{m,} - повторения от m и более раз; 
{,n} - повторения не более n раз.

Для всех этих форм можно записать минорный режим: {m,}? и {,n}?.
"""

match = re.findall(r"Go{2,}gle", text)  # Буквы о идут от двух и более.
print(match)

match = re.findall(r"Go{,4}gle", text)  # Букв о должно быть не более 4.
print(match)

phone = "89123456789"
match = re.findall(r"8\d{10}", phone)  # Проверяем правильность записи номера телефона (первая восьмёрка, а далее
# 10 цифр). \d - означает цифру, а {10} - квантификатор на 10 повторений.
print(match)

"""
Часто встречающиеся записи квантификаторов - {0,} и {1,}.
Аналоги их записи:
    ? - от нуля до одного (аналог {0,1});
    * - от нуля и до "бесконечности" (в действительности, большого числа - от 32767), соответствует квантификатору {0,}; 
    + - от единицы и до "бесконечности" (также большого числа - от 32767), соответствует квантификатору {1,}.
    P.s.: все они могут быть использованы и в минором режиме: ??, *?, +?.
"""

text = "стеклянный, стекляный"
match = re.findall(r"стеклянн?ый", text)  # Комбинация н? будет говорить, что эта буква н (перед знаком вопроса)
# не является обязательной, т.е. повторяется от 0 до 1 раз.
print(match)

text = "author=Пушкин А.С.; title=Евгений Онегин; price =200; year= 2001"
match = re.findall(r"\w+\s*=\s*[^;]+", text)  # \w - символы слова, + - этих символов слова должно быть от 1 до
# бесконечности, далее стоит знак равно (но перед ним и после него могут быть пробелы в любом количестве), и затем мы
# выделяем все слова, кроме точки с запятой (в любом количестве).
print(match)

"""
Преимущество регулярных выражений перед обычным методом split() в том, что мы точно проверяем, что сначала идёт слово.
Ещё одним преимуществом является то, что мы можем сразу провести какую-то тонкую работу с получившимися строками.
"""

match = re.findall(r"(\w+)\s*=\s*([^;]+)", text)  # Теперь мы получаем кортежи из ключа + значения.
print(match)

text = "<p>Картинка <img alt='Картинка' src='bg.jpg'> в тексте</p>"
match = re.findall(r"<img.*>", text)  # Выделяем не только фрагмент img, но и всё остальное. Т.е. мы говорим
# программе после img взять любой символ от 0 до бесконечности, пока не встретим угловую скобку. Но т.к. наш
# квантификатор мажорный, то он будет искать наибольшую последовательность.
print(match)

match = re.findall(r"<img.*?>", text)  # Теперь получили только первое совпадение по закрывающей скобке.
print(match)

match = re.findall(r"<img[^>]*>", text)  # Получим тот же самый вывод, ибо мы указали, что ожидаем получить любой
# символ, кроме угловой звёздочки, а затем закрываем эту скобку. Но наше решение примет и пустой тэг img, исправим это:
print(match)

match = re.findall(r"<img\s+[^>]*?src\s*=\s*[^>]+>", text)
print(match)
