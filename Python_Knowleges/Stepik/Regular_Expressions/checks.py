import re

text = "подоходный налог"
match = re.findall(r"прибыль|обредение|доход", text)  # Нашли совпадение там, где этого не предполагается.
print(match)

match = re.findall(r"прибыль|обредение|\bдоход\b", text)  # Добавляем проверку границы слова.
print(match)  # Теперь доход не выводится, ибо не является самостоятельным словом в выражении.

# Если нужно находить несколько отдельных слов, то лучше прописать группирующую скобку, а уже вне её добавлять границу:
text = "подоходный налог, доход"
match = re.findall(r"\b(?:прибыль|обредение|доход)\b", text)
print(match)

"""
В общем случае для регулярных выражений доступны следующие проверки:

Символ                  Описание

^                       Начало текста (с флагом re.MULTILINE - начало строки)

$                       Конец текста ( с флагом re.MULTILINE - позиция перед символом переноса строки \n)

\A                      Начало текста

\b                      Граница слова (внутри символьных классов [] соответствует символу BACKSPACE)

\B                      Граница не слова (зависим от флага re.ASCII)

\Z                      Конец текста

(?=exp)                 Проверка на совпадение с выражением exp продолжения строки. При этом позиция поиска не смещается
                        на выражение exp (опережающая строка)

(?!exp)                 Проверка на не совпадение с выражением exp продолжения строки (также опережающая строка)

(?<=exp)                Проверка на совпадение с выражением exp хвоста уже обработанной (проверенной) строки. Она также
                        называется позитивной ретроспективной проверкой.

(?<!exp)                Проверка на несовпадение с выражением exp хвоста уже обработанной (проверенной) строки. Ещё она
                        называется негативной ретроспективной проверкой.
"""

text = """
<!DOCTYPE html>
<html lang="ru">
<head>
<meta http-equiv="Content-Type" content="text/html; charset="windows-1251">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Уроки по Python</title>
</head>
<body>
<script type="text/javascript">
let o = document.getElementById('id_div');
console.log(obj);
</script>
</body>
</html>
"""

match = re.findall(r"^<script.*?>([\w\W]+)(?=</script>)", text, re.MULTILINE)
print(match)  # Вывод: ["\nlet o = document.getElementById('id_div');\nconsole.log(obj);\n"]

match = re.findall(r"^<script.*?>([\w\W]+)(?<=</script>)", text, re.MULTILINE)  # Теперь мы получаем закрывающий
# тэг, благодаря ретроспективной проверке.
print(match)  # Вывод:["\nlet o = document.getElementById('id_div');\nconsole.log(obj);\n</script>"]

"""
Всё отличие ретроспективной проверки о опережающей в том, что в первом случае мы не захватываем элемент остановки 
(опережающая), а во втроем случае - мы захватываем элемент остановки (ретроспективная).

Примечание: в нашем шаблоне мы используем \w и \W вместо точки потому, что указываем все символы и буквы. В то время, 
как точка не захватывает символ переноса строки. Таким образом, прописав точку, мы получим пустой список.
"""

# Из нашей HTML-страницы выделим все пары ключ и значение.
match = re.findall(r"([-\w]+)[ \t]*=[ \t]*[\"']([^\"']+)(?<![ \t])", text, re.MULTILINE)  # Благодаря
# ретроспективной проверке мы пропустим все пробелы около ключей или значений.
print(match)

"""
Далее мы изменим наш HTML-файл. Уберём кавычки у тэга p. При этом мы всё равно хотим включить данную пару ключа и 
значения в конечный вывод. 
Для выполнения такой задачи есть конструкция: (?P<q>[\"'])
Итоговый вариант будет примерно следующим:
(?(id|name)yes_pattern) или (?(id|name)yes_pattern|no_pattern)
"""

text = """
<!DOCTYPE html>
<html lang="ru">
<head>
<meta http-equiv="Content-Type" content="text/html; charset="windows-1251">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Уроки по Python</title>
</head>
<body>
<p align=center>Hello World!</p>
</body>
</html>
"""

match = re.findall(r"([-\w]+)[ \t]*=[ \t]*(?P<q>[\"'])?(?(q)([^\"']+(?<![ \t]))|([^ \t>]+))", text, re.MULTILINE)
print(match)

"""
Набор флагов, которые можно назначать регулярным выражениям:

Флаг                    Описание

re.A или re.ASCII       При этом флаге проверки \b, \B, \s, \S, \w и \W действуют так, как если бы применялись к тексту,
                        содержащему только символы ASCII (по умолчанию используется Юникод re.U/re.UNICODE и лучше 
                        оставаться в этом режиме)

re.I или re.IGNORECASE  Проверка без учёта регистра символов

re.M или re.MULTILINE   Влияет на проверки ^ и $. Начало ^ считается началом строки (сразу после символа \n или начало 
                        текста). Конец $ считается в позиции перед \n (или конец строки)

re.S или re.DOTALL      При установке этого флага символ точки также включает символ перевода строки \n

re.X или re.VERBOSE     Позволяет включать в регулярные выражения пробелы и комментарии

re.DEBUG                Включает режим отладки при компиляции регулярного выражения

Также можно прописать сразу несколько флагов:
(?flags), где flags - один или несколько флагов:
    a - то же самое, что re.ASCII;
    i - соответствует re.IGNORECASE;
    m - для re.MULTILINE;
    s - для re.DOTALL;
    x - для re.VERBOSE.
"""

match = re.findall(r"""([-\w]+)  # Выделяем атрибут
                                [ \t]*=[ \t]*  # далее, должно идти равно и кавычки
                                (?P<q>[\"'])?  # проверяем наличие кавычки
                                (?(q)([^\"']+(?<![ \t]))|([^ \t]+))  # выделяем значение атрибута
                                """,
                   text, re.MULTILINE|re.DEBUG)
print(match)

text = "Python, python, PYTHON"
match = re.findall(r"(?im)python", text)
print(match)
