import re

text = 'Карта map и объект bitmap - это разные вещи'

match = re.findall('map', text)  # Все вхождения подстроки в строке.
print(match)  # Возвращается список.

match = re.findall('\\bmap\\b', text)  # Все вхождения, но только в том случае, когда map является отдельным
# словом.
print(match)

match = re.findall(r'\bmap\b', text)  # Теперь можно использовать всего 1 слэш.
print(match)

"""
Сами методы модуля написаны на языке С, что даёт высокую скорость обработки строк.

В практике программирования регулярные выражения используются для следующих типовых задач: 
    - проверка вхождения фрагмента текста заданному шаблону (например, формат записи номера телефона);
    - поиск подстрок по указанному шаблону в тексте;
    - поиск и замена регулярного выражения на заданную строку;
    - разбиение строки по найденным шаблонам, записанного в виде регулярного выражения (например, данные записанные в 
    строке как ключ=значение разбиваются отдельно на ключи и значения).

При поиске мы задаём комбинацию символов, которая далее будет найдена в тексте, например: 
"""

text = 'еда, беда, победа'

match = re.findall(r'еда', text)
print(match)

"""
Но не все символы можно так записать. Есть специальные символы, которые относятся к языку регулярных выражений: 
\.^$?+*{}[]()|
Если записать без экранирования символы выше, то будет искаться функционал, связанный с этими символами.
К примеру, если бы мы просто указали: 

match = re.findall(r'(еда)', text)
print(match)

, то не получили бы нужного результата, ибо () выполняют определённую функцию. Однако изменив запись на:

match = re.findall(r'\(еда\)', text)
print(match)

мы получим поиск по символам (еда), соответственно, в данном тексте ничего и не найдём.
Однако внутри регулярных выражений можно использовать спецсимволы табуляции/переноса строки и др.

Часто требуется найти не какую-то одну форму слова, а все его формы (еда, Еда, еду и т.д.). Чтобы охватить все варианты,
то мы в нашем шаблоне можем использовать символьные классы [набор символов, который нужно искать в нужной позиции]:
"""

text = 'Еда, еду, Еду'

match = re.findall(r'[Ее]д[ау]', text)
print(match)

# Поиск любой цифры в тексте:
text = 'Еда, беда, 55 победа'

match = re.findall(r'[0123456789]', text)  # Для поиска 2 цифр подряд: r'[0123456789][0123456789]'. Однако так
# нельзя будет найти цифру 5, а затем следом за ней 55.
print(match)

# Также в символьных выражениях можно указывать интервал для удобства:
match = re.findall(r'[0-9][0-9]', text)
print(match)

# Если также требуется захватить и минус:
text = '(Еда), беда, -5 55 победа?'

match = re.findall(r'[-0-9][0-9]', text)
print(match)

# Если требуется находить не цифры:
match = re.findall(r'[^0-9]', text)  # В данном случае найдутся все элементы, кроме цифр.
print(match)

# Перебираем все буквы от а до я:
match = re.findall(r'[а-я]', text)
print(match)

# Перебираем все русские буквы без учёта регистра:
match = re.findall(r'[а-яА-я]', text)
print(match)

# Если хотим добавить ещё и цифры:
match = re.findall(r'[а-яА-я0-9]', text)
print(match)

# Внутри квадратных скобок даже спецсимволы будут восприниматься как обычные (но только кроме обратного слэша \):
match = re.findall(r'[а-яА-я0-9?()]', text)
print(match)

"""
Символ          Выражение

.               Соответствует любому символу, кроме символа переноса строки (\n). Но если установлен флаг re.DOTALL, то 
                точка соответствует вообще любому символу в тексте. Однако если она записана внутри символьного класса, 
                то воспринимается как символ точки.

\d              Соответствует любой цифре, если используется кодировка Юникода. Если же установлен флаг re.ASCII, то 
                диапазону цифр [0-9].

\D              Соответствует любому не цифровому символу для Юникода или символьному классу [^0-9] при установленном 
                флаге re.ASCII.

\s              Для Юникода - любой пробельный символ. Для re.ASCII - символьный класс [ \t\n\r\f\v]

\S              Для не пробельный символ. Для Для re.ASCII - символьный класс [^ \t\n\r\f\v]

\w              Для Юникода - любой символ слова. При флаге re.ASCII - набору символов [a-zA-z0-9_]

\W              Для Юникода - любой не символ слова. При флаге re.ASCII - набору символов [^a-zA-Z0-9_]
"""

text = 'Еда, беда, -5 55 победа'
match = re.findall(r'\d', text)
print(match)

match = re.findall(r'.', text)
print(match)

match = re.findall(r'\w', text, re.ASCII)
print(match)

# Разберём пример с числами в 16-тиричном формате:
text = '0xf, 0xa6 0x5'
match = re.findall(r'0x[\da-fA-F]', text)
print(match)
# Закрепим в конце: точка вне символьного класса соответствует любому символу, а вот внутри - только точке.
