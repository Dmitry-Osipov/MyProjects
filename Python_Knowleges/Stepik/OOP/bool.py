"""
__len__() - вызывается функцией bool(), если не определён магический метод __bool__.
__bool__() - вызывается в приоритетном порядке функцией bool().

Рассмотрим способы настройки и определения правдивости объектов классов. Правдивость - это когда к экземпляру класса
явно или не явно применяется функция bool().
"""

print(f'{bool(123)}, {bool(-1)}, {bool(0)}, {bool("python")}, {bool("")}, {bool([])}')  # Если значение непустое, True.


class Point:
    def __init__(self, x_coord, y_coord):
        self.x_coord = x_coord
        self.y_coord = y_coord


p = Point(3, 4)
print(bool(p))  # Видим True. В действительности функция bool() всегда возвращает True для любых объектов
# пользовательского класса. Тогда получается, что особого смысла в этой функции нет. Не совсем, ведь мы можем
# переопределить её поведение через магический метод __len__ либо __bool__. Для начала воспользуемся функцией __len__:


class Point1:
    def __init__(self, x_coord, y_coord):
        self.x_coord = x_coord
        self.y_coord = y_coord

    def __len__(self):  # Будем возвращать квадрат длины радиус-вектора.
        print('__len__')  # Проверка отработки.
        return self.x_coord * self.x_coord + self.y_coord * self.y_coord


p1 = Point1(3, 4)
print(len(p1))
print(bool(p1))  # Вывод примерно одинаковый (у len() - 25, у bool() - True (ибо от любого числа не равного 0 bool()
# выдаст True)), print внутри __len__ отработал оба раза, что означает, что магический метод __len__ сработал оба раза.

p1 = Point1(0, 0)
print(bool(p1))  # А если выставить p1 = Point1(0, 0), то мы поменяем поведение функции bool() (она будет принимать
# число 0 от магического метода __len__, что при отработке bool() даёт False. А чтобы скорректировать работу функции
# bool() для наших экземпляров, то нужно реализовать магический метод __bool__, который работает в приоритете (т.е. если
# при вызове функции bool() находится магический метод __bool__, то именно он и вызывается:


class Point2:
    def __init__(self, x_coord, y_coord):
        self.x_coord = x_coord
        self.y_coord = y_coord

    def __len__(self):
        print('__len__')
        return self.x_coord * self.x_coord + self.y_coord * self.y_coord

    def __bool__(self):
        print('__bool__')  # Проверка отработки.
        return self.x_coord == self.y_coord  # В учебных целях реализуем простую работу данного магического метода.
        # Обязательно магический метод __bool__ должен возвращать только булева-значение.


p2 = Point2(10, 10)
print(bool(p2))  # При любых равных координатах выводит True. Если же координаты будут отличаться, то выведет False.
# Но где это может понадобиться? Обычно функцию bool() в явном виде не вызывают. Обычно она вызывается неявно в условных
# операторах:

if p2:
    print('Объект p2 даёт True')
else:
    print('Объект p2 даёт False')
