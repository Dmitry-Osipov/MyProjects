"""
Метакласс - это объект (в Python всё является объектами). Но это объект особого рода, который нельзя порождать
динамически. Он является вершиной, отправной точкой, для создания обычных классов (bool, str, int и т.д.) и,
следовательно, их объектов (False, 'Hello', 123 и т.д.). Но что является метаклассом в языке Python? Давно знакомый
объект type, который мы использовали для определения типов других объектов. Но это если он вызывается с одним
аргументом (type(объект)). Если же передать ему 3 аргумента (type(name, bases, dct)), т.е. имя класса (name), список
родительских классов (bases), словарь с атрибутами (dct), то данный объект type начинает работать совершенно по-другому:
создаёт динамически новый класс, новый тип данных. На самом деле все типы данных (int, str, float, list и т.д.)
порождены этим метаклассом, в чём легко убедиться:
"""

print(type(int), type(str))  # <class 'type'> <class 'type'>. Даже если прописать свой простейший класс, то мы увидим
# аналогичный вывод.


class A:
    pass


print(type(A))  # <class 'type'>. Таким образом, всё, что порождается в python исходит от метакласса type.

"""
Но зачем нам метакласс? Мы же и так можем объявлять классы в своих программах. Для чего их создавать динамически 
в процессе работы программы? На этот вопрос ответил Тим Питтерс:
<<
Метаклассы - это глубокая магия, о которой 99% пользователей даже не нужно задумываться. Если вы думаете, нужно ли вам 
их использовать - вам не нужно (люди, которым они реально нужны, точно знают, зачем они им, и не нуждаются в 
объяснениях, почему).
>>

Но мы всё же ознакомимся. Попробуем создать с помощью объекта type простейший класс точки на плоскости:
"""


class Point:
    MAX_COORD = 100
    MIN_COORD = 0


# Чтобы создать класс через type, в аргументах нужно указать имя класса; кортеж классов, от которых наследуемся
# (у нас пустой); далее словарь с двумя атрибутами: MAX_COORD и MIN_COORD.

A = type('Point', (), {'MAX_COORD': 100, 'MIN_COORD': 0})
print(type(A), A.__dict__)  # Видим, что мы создали <class 'type'>, с атрибутами 'MAX_COORD': 100, 'MIN_COORD': 0.

pt = A()
print(pt)  # Объект класса был создан: <__main__.Point object at 0x000001AAD67EA610>. Соответственно, мы можем
# обратиться к любому атрибуту класса. Попробуем прописать наследование:


class B1:
    pass


class B2:
    pass


A = type('Point', (B1, B2), {'MAX_COORD': 100, 'MIN_COORD': 0})
print(A.__mro__)  # Видим, что наследование сработало:
# (<class '__main__.Point'>, <class '__main__.B1'>, <class '__main__.B2'>, <class 'object'>). Конечно, когда мы
# динамически создаём классы, то в них можно добавлять и методы, т.е. это тоже атрибуты, которые ссылаются на
# объект-функцию. 1 способ создать метод в глобальном пространстве имён, а далее в словаре для создания класса передаём
# строку с название класса в качестве ключа, а в качестве значения передаём ссылку на функцию:


def method1(self):  # Обязательно должен быть параметр self, который будет ссылаться на экземпляр класса.
    print(self.__dict__)


A = type('Point', (B1, B2), {'MAX_COORD': 100, 'MIN_COORD': 0, 'method1': method1})
pt = A()
pt.method1()  # Локальных свойств у объекта нет, соответственно, получили ожидаемый вывод: {}

# 2 способ передачи метода в класс заключается в том, что мы также заводим название в словаре в качестве ключа, но уже в
# качестве значения передаём лямбда-функцию (лямбда-функция должна так же принимать параметр self):

A = type('Point', (B1, B2), {'MAX_COORD': 100, 'MIN_COORD': 0, 'method1': lambda self: self.MAX_COORD})
pt = A()
print(pt.method1())  # Как и ожидали, получаем значение MAX_COORD: 100

"""
Итак, у нас всё получилось. Но на деле добавлять методы и атрибуты именно таким образом не очень удобно. Выход есть:
в Python мы можем создавать собственные метаклассы. Конечно, явно или неявно, наши метаклассы будут использовать 
метакласс type. Допустим, мы хотим создать класс Point:
class Point:
    MAX_COORD = 100
    MIN_COORD = 0

Создадим свой метакласс, который буде представляться в виде обычной функции. Да, функцию можно использовать в качестве 
метакласса. В качестве аргументов она снова будет принимать имя, список базовых классов и словарь атрибутов.
"""


def create_class_point(name, base, attrs):
    attrs.update({'MAX_COORD': 100, 'MIN_COORD': 0})  # Задаём заранее нужные нам атрибуты. Если словарь изначально был
    # пустым то мы добавим эти значения. А если эти значения уже были заданы, то мы их обновим.
    return type(name, base, attrs)  # Это самый простой вариант по описанию простейшего метакласса с помощью функции.


class Point(metaclass=create_class_point):
    def get_coords(self):
        return (0, 0)


"""
Теперь при создании класса Point будет отрабатывать метакласс, который мы передали по специальной ссылке, и фактически 
будет создаваться класс Point по образу и подобию алгоритма, который мы прописали в функции.
"""

pt = Point()
print(pt.MAX_COORD)  # Эта строчка прочитала атрибут, который мы добавили в метаклассе.
print(pt.get_coords())  # Эта строчка отработала, когда мы вызываем метод из самого класса привычным нам способом.

"""
Таким образом, мы понимаем, что по ссылке в аргументе metaclass, отработала функция, Python автоматически подставил 
название класса, родительские классы, а также обновил словарь.
Конечно, использование функций в качестве метаклассов - это учебный пример. На практике используют отдельные классы, 
которые играют роль метаклассов:
"""


class Meta(type):  # Т.к. наш класс является метаклассом, то он должен наследоваться от type.
    def __init__(cls, name, base, attrs):  # Первым параметром в инициализаторе идёт ссылка на созданный класс (Point),
                                           # потом имя, потом кортеж из базовых классов, а потом словарь атрибутов.
        super().__init__(name, base, attrs)  # По-хорошему, мы должны вызвать инициализатор базового класса на всякий случай.
        cls.MAX_COORD = 100  # Динамически добавляем 2 свойства.
        cls.MIN_COORD = 0  # Почему мы пишем через cls? Новый класс на момент вызова инициализатора уже создан, поэтому
                           # чтобы что-то добавить в этот новый, уже созданный класс, мы динамически добавляем в него
                           # эти 2 атрибута MAX_COORD и MIN_COORD/


class Point(metaclass=Meta):  # Отрабатывает всё аналогично функции, но добавляется ссылка cls на уже созданный класс Point.
    def get_coords(self):
        return (0, 0)


pt = Point()
print(pt.MAX_COORD)
print(pt.get_coords())

"""
Видим, что у нас всё отработало. Однако для более тонкой работы при создании метакласса стоит прописывать вместо 
магического метода __init__ магический метод __new__, который вызывается непосредственно перед созданием класса. 
"""


class Meta(type):
    def __new__(cls, name, base, attrs):  # Передаём cls - ссылка на класс Meta, а затем 3 знакомых нам параметра.
        attrs.update({'MAX_COORD': 100, 'MIN_COORD': 0})  # Т.к. класс ещё не создан, то мы не можем напрямую
        # присваивать значения атрибутов. Следует использовать метод update.
        return type.__new__(cls, name, base, attrs)  # Вызываем у type метод __new__, куда последовательно передаём
        # класс Meta, имя создаваемого класса, кортеж из базовых классов, словарь с атрибутами нового создаваемого класса


class Point(metaclass=Meta):
    def get_coords(self):
        return (0, 0)


pt = Point()
print(pt.MAX_COORD)
print(pt.get_coords())

"""
Снова видим, что всё отработало. Причём если удалить строку с обновлением словаря, то мы увидим, что 162 строчка выдаст 
ошибку, ибо внутри класса Point мы не инициализировали MAX_COORD.
Может появиться вопрос: в чём преимущество метаклассов, создаваемых классом, над метаклассами, создаваемых функциями.
Принципиальных отличий здесь нет. Любой алгоритм можно прописать и на уровне функций, и на уровне класса. Однако при 
использовании класса у нас в руках оказывается вся мощь ООП. В частности, можно создавать иерархии для формирования 
сложного поведения метаклассов. И в крупных проектах это заметно облегчает код, делая его гораздо читабельнее. 
Поэтому на практике для определения метаклассов чаще используются классы.

А теперь рассмотрим применение на практике.
Фреймворк Django использует метаклассы для связи объектов с записями в базы данных. Т.е. метаклассы используются в 
API ORM DJANGO. 
В частности он делает следующее: можно определить некий класс модели с набором атрибутов (причём эти атрибуты совпадают
с соответствующими полями таблицы в базе данных). Например:
class Women(models.Model):
    title = ...
    content = ...
    photo = ...
    time_create = ...
    time_update = ...
    is_published = ...
    
Т.е. в нашей модели Women есть атрибут title, content, photo и т.д. А затем во фреймворке Django нам достаточно создать 
экземпляр этого класса, чтобы получить все записи, которое содержат определённое поле. Например:
w = Women(title='Ума Турман')
Таким образом, после создания экземпляра класса Women у нас в объекте w автоматически появляются локальные свойства с 
точно такими же именами, что и атрибуты класса (title, photo, content и т.д.), но эти локальные свойства уже будут 
содержать конкретные данные записи, которую мы достали. Например, photo=photos/2121/212.jpg, time_create=3.2.21, и т.д.
И эта магия по автозаполнению данных и выполняется на уровне метаклассов. В действительности класс Model, от которого 
наследуется класс Women и является метаклассом. Этот метакласс и добавляет необходимый функционал в класс Women.
Создадим свой метакласс, который будет реализовывать тот же функционал:
"""


class Meta(type):
    def create_local_attrs(self, *args, **kwargs):  # Этот метод по своей сути будет инициализатором класса Women.
        # В этом методе мы будем формировать локальные свойства объектов класса Women. Т.е. он отработает, когда
        # класс Women будет создан.
        for key, value in self.class_attrs.items():
            self.__dict__[key] = value

    def __init__(cls, name, base, attrs):
        cls.class_attrs = attrs  # Эта коллекция будет находиться в классе Women.
        cls.__init__ = Meta.create_local_attrs  # Здесь мы добавляем в класс Women инициализатор.


class Women(metaclass=Meta):
    title = 'заголовок'
    content = 'контент'
    photo = 'путь к фото'


w = Women()
print(w.__dict__)  # {'__module__': '__main__', '__qualname__': 'Women', 'title': 'заголовок', 'content': 'контент', 'photo': 'путь к фото'}

"""
Видим, что всё отработало корректно. В итоге теперь нам гораздо проще прописывать новый класс. Т.е.:

Было:
class Women:
    class_attrs = {'title': 'заголовок', 'content': 'контент', 'photo': 'путь к фото'}
    title = 'заголовок'
    content = 'контент'
    photo = 'путь к фото'
    
    def __init__(self, *args, **kwargs):
        for key, value in self.class_attrs.items():
            self.__dict__[key] = value
            
Стало:
class Women(metaclass=Meta):
    title = 'заголовок'
    content = 'контент'
    photo = 'путь к фото'
    
Таким образом, лишь 1 раз прописав собственный метакласс, мы можем создавать другие классы гораздо быстрее и проще.

Итак, мы реализовали упрощённый метакласс из API ORM DJANGO своими руками.
Конечно, очевидным плюсом является скорость написания следующих классов. Однако не следует забывать, что создание 
метаклассов несёт под собой усложнение системы. Как следствие, неумелое обращение с таким инструментарием и код будет 
задерживать, и будет источником непредвиденных ошибок, которые крайне сложно будет уловить.
Так что следует всегда держать в голове слова Тима Питтерса:
<<
Метаклассы - это глубокая магия, о которой 99% пользователей даже не нужно задумываться. Если вы думаете, нужно ли вам 
их использовать - вам не нужно (люди, которым они реально нужны, точно знают, зачем они им, и не нуждаются в 
объяснениях, почему).
>>
"""
