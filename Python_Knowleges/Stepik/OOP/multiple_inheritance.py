"""
В языке Python допускается множественное наследование - когда один дочерний класс наследуется от нескольких базовых:
class A(B1, B2, B3 ... N).
Данный тип наследования применяется не так часто, как обычное наследование от одного базового класса, тем не менее это
тоже важный механизм и некоторые подходы его активно используют.
Например, идеи миксины (mixins) - примеси - реализуются через множественное наследование. На их примере и будем учиться.
Представим, что мы делаем некий интернет-магазин по продаже товаров, например, ноутбуков, дисков процессоров и т.д.
Каждый товар будет определяться своим классом. У всех этих классов будет общий базовый класс Goods, также у каждого
товара обязательно будут следующе параметры: наименование, вес, цена.
"""


class Goods:
    def __init__(self, name, weight, price):
        print('init Goods')
        self.name = name
        self.weight = weight
        self.price = price

    def print_info(self):
        print(f'{self.name}, {self.weight}, {self.price}')


class NoteBook(Goods):
    pass


n = NoteBook('Acer', 1.5, 30_000)
n.print_info()
"""
Видим, что у нас сработал инициализатор базового класса, были созданы все локальные атрибуты, метод
print_info() как раз их и вывел в консоль. Далее представим, что к нам приходит тимлид и просит добавить возможность
логирования товаров магазина. Плохим вариантом будет прописывать логику логирования в базовом классе Goods либо в
базовом классе уровня выше. Хорошим же вариантом будет воспользоваться идеей миксинов. Для этого создадим 
вспомогательный класс:
"""


class Goods:
    def __init__(self, name, weight, price):
        print('init Goods')
        self.name = name
        self.weight = weight
        self.price = price

    def print_info(self):
        print(f'{self.name}, {self.weight}, {self.price}')


class MixinLog:
    ID = 0

    def __init__(self):
        print('init MixinLog')
        MixinLog.ID += 1
        self.id = MixinLog.ID

    def save_sell_log(self):
        print(f'{self.ID}: товар был продан в 00:00 часов')
    # Таким образом, получился ещё один класс, который работает совершенно независимо от классов NoteBook и Goods, и
    # лишь добавляет определённый функционал логирования товаров с использованием их id. Такие независимые базовые
    # классы и получили название Mixin - примеси.


class NoteBook(Goods, MixinLog):  # Сейчас у нас получилось, что дочерний класс NoteBook наследуется от двух базовых
    # классов Goods и MixinLog. При этом функционал дочернего класса содержит функционал обоих классов.
    pass


n = NoteBook('Acer', 1.5, 30_000)
n.print_info()
n.save_sell_log()
"""
Мы не увидели в выводе строки с инициализатором класса MixinLog, ибо, как мы уже знаем, при создании объектов 
инициализатор сначала ищется в дочернем классе (потому что именно объект дочернего класса создаётся), а затем в базовых 
классах. Причём сначала в первом базовом классе Goods, а затем во втором - MixinLog. Т.к. у нас в Goods есть 
инициализатор, то он был выполнен и на этом всё завершилось. Второй инициализатор (в классе MixinLog) не вызывался. Но 
нам нужно, чтобы он тоже вызывался. Как это реализовать? Обычно в инициализаторах базового класса прописывают:
"""


class Goods:
    def __init__(self, name, weight, price):
        super().__init__()  # Создали объект-посредник с помощью super(), который делегирует вызов инициализатора
        # соответствующего базового класса (в данном случае будет вызван __init__ у MixinLog.
        print('init Goods')
        self.name = name
        self.weight = weight
        self.price = price

    def print_info(self):
        print(f'{self.name}, {self.weight}, {self.price}')


class MixinLog:
    ID = 0

    def __init__(self):
        print('init MixinLog')
        MixinLog.ID += 1
        self.id = MixinLog.ID

    def save_sell_log(self):
        print(f'{self.id}: товар был продан в 00:00 часов')


class NoteBook(Goods, MixinLog):
    pass


n = NoteBook('Acer', 1.5, 30_000)
n.print_info()
n.save_sell_log()
"""
По итогу видим, что были вызваны оба инициализатора, также обновилось значение ID с 0 - как было ранее - до 1. 
Соответственно, всё работает так, как мы и задумывали. Но остаётся вопрос: откуда функция super() в базовом классе Goods
Знает, что нужно обратиться именно ко второму инициализатору MixinLog, а не к базовому классу object, от которого 
наследуется все классы?
Всё просто: в Python существует специальный алгоритм обхода базовых классов при множественном наследовании, сокращённо:
MRO - Method Resolution Order. При нашей иерархии наследования:
           - > Goods   - 
          |             |
NoteBook -               - > object
          |             |
           -> MixinLog - 
MRO будет обходить базовые классы в следующем порядке: вначале обращаемся к дочернему классу NoteBook (там будем искать 
необходимые методы), если не найдём, то к первому базовому классу Goods (записан первым в списке наследования), далее к 
следующему классу MixinLog, а уже от него к классу object. Данную цепочку для любого класса мы можем посмотреть 
при помощи специальной коллекции: 
"""

print(NoteBook.__mro__)  # Поочерёдно вывел кортеж классов, которые обходятся при поиске того или иного атрибута.
"""
Таким образом, мы можем быть уверены, что инициализатор первого базового класса точно сработает первым. Это важно
потому, что при создании объекта NoteBook мы передаём 3 аргумента: название, вес, цена. Далее 3 аргумента передаются в 
инициализатор, который прописан в классе Goods. Т.к. первым будет вызван инициализатор именно этого класса, то мы 
уверены, что эти аргументы будут переданы именно в него, а не в какой-то другой инициализатор каких-то других базовых 
классов. И какая цепочка наследования у нас бы ни была, всё равно первым будет вызываться __init__ класса Goods, ибо при 
создании класса NoteBook он записан первым. Это гарантирует работоспособность программы при разных иерархиях сложности.
Если поменять порядок наследования, то в нашем примере выйдет ошибка, ибо инициализатор класса MixinLog ожидает получить 
1 аргумент, а получает сразу 4.
Таким образом, всегда первым должен идти основной базовый класс, у которого, как правило, используется инициализатор 
с какими-то дополнительными параметрами. А далее прописываются классы, у которых, как правило инициализаторы не имеют 
дополнительных параметров - только параметр self.
Когда мы собираемся использовать множественное наследование, то структуру иерархии надо продумывать так, чтобы 
инициализаторы вспомогательных базовых классов (которые при реализации дочернего класса записаны вторыми, третьими, 
четвёртыми и т.д.) имели бы только один параметр self и никаких дополнительных, иначе будут сложности их использования.
В чём состоят сложности? Для примера пропишем в инициализаторе класса MixinLog 1 дополнительный параметр: 
"""


class Goods:
    def __init__(self, name, weight, price):
        super().__init__(1)  # Для того, чтобы не получить ошибки недостатка аргументов у инициализатора класса MixinLog
        # мы просто поставим какое-то значение для передачи его в параметр p1.
        print('init Goods')
        self.name = name
        self.weight = weight
        self.price = price

    def print_info(self):
        print(f'{self.name}, {self.weight}, {self.price}')


class MixinLog:
    ID = 0

    def __init__(self, p1):
        print('init MixinLog')
        MixinLog.ID += 1
        self.id = MixinLog.ID

    def save_sell_log(self):
        print(f'{self.id}: товар был продан в 00:00 часов')


class NoteBook(Goods, MixinLog):
    pass


n = NoteBook('Acer', 1.5, 30_000)


"""
А что, если у нас 2 миксина используются?
"""


class Goods:
    def __init__(self, name, weight, price):
        super().__init__(1)
        print('init Goods')
        self.name = name
        self.weight = weight
        self.price = price

    def print_info(self):
        print(f'{self.name}, {self.weight}, {self.price}')


class MixinLog:
    ID = 0

    def __init__(self, p1):
        super().__init__(1, 2)  # Теперь мы должны указать уже 2 параметра для p1 и p2.
        print('init MixinLog')
        MixinLog.ID += 1
        self.id = MixinLog.ID

    def save_sell_log(self):
        print(f'{self.id}: товар был продан в 00:00 часов')


class MixinLog2:
    def __init__(self, p1, p2):
        print('init MixinLog2')


class NoteBook(Goods, MixinLog, MixinLog2):
    pass


n = NoteBook('Acer', 1.5, 30_000)

"""
Но допустим нашу программу использует программист, который не знает про эти "особенности" наших классов, и просто 
поменял местами: class NoteBook(Goods, MixinLog2, MixinLog) - конечно, вылезет ошибка, ибо обход классов теперь другой, 
соответственно, мы и должны передавать аргументы в super() каждого из базовых классов по-другому. А все эти проблемы 
создались только потому, что мы в инициализаторах миксинов задали какие-то аргументы, кроме self.
Последнее, что мы сегодня зацепим - это что будет, если вызвать методы с одинаковыми именами в базовых классах. 
Предположим, что в классах Goods и MixinLog есть разные методы с одинаковыми названиями:
"""


class Goods:
    def __init__(self, name, weight, price):
        super().__init__()  # Создали объект-посредник с помощью super(), который делегирует вызов инициализатора
        # соответствующего базового класса (в данном случае будет вызван __init__ у MixinLog).
        print('init Goods')
        self.name = name
        self.weight = weight
        self.price = price

    def print_info(self):
        print(f'{self.name}, {self.weight}, {self.price}')


class MixinLog:
    ID = 0

    def __init__(self):
        print('init MixinLog')
        MixinLog.ID += 1
        self.id = MixinLog.ID

    def save_sell_log(self):
        print(f'{self.id}: товар был продан в 00:00 часов')

    def print_info(self):
        print('Вызывается метод print_info из класса MixinLog')


class NoteBook(Goods, MixinLog):
    pass


n = NoteBook('Acer', 1.5, 30_000)
n.print_info()  # Первым и единственным отработает метод из класса Goods, ибо в иерархии наследования он идёт первым.
"""
Но что если мы хотим вызывать print_info() не из Goods, а из MixinLog? Существуют 2 распространённых способа: 
1) если нам нужно сделать частный вызов print_info() именно из MixinLog, то это можно сделать так: прописать класс прямо 
по ходу работы программы, вызвать оттуда print_info и передать в качестве первого аргумента ссылку на объект NoteBook:
"""

MixinLog.print_info(n)

"""
Но если нам нужно всегда print_info() вызывать из второго класса MixinLog, то лучше сделать вторым способом: определить 
метод print_info() в дочернем классе (переопределить метод), а внутри этого метода мы будем явно указывать откуда идёт 
вызов этого метода (реализация аналогична записи выше):
"""


class Goods:
    def __init__(self, name, weight, price):
        super().__init__()
        print('init Goods')
        self.name = name
        self.weight = weight
        self.price = price

    def print_info(self):
        print(f'{self.name}, {self.weight}, {self.price}')


class MixinLog:
    ID = 0

    def __init__(self):
        print('init MixinLog')
        MixinLog.ID += 1
        self.id = MixinLog.ID

    def save_sell_log(self):
        print(f'{self.id}: товар был продан в 00:00 часов')

    def print_info(self):
        print('Вызывается метод print_info из класса MixinLog')


class NoteBook(Goods, MixinLog):
    def print_info(self):
        MixinLog.print_info(self)


n = NoteBook('Acer', 1.5, 30_000)
n.print_info()

"""
Такое переопределение работает только в том случае, если этот метод определён в обоих базовых классах. Ибо если бы 
такого метода не было бы в Goods, то алгоритм MRO просто нашёл бы этот метод в MixinLog.
"""
