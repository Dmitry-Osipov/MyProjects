class Person:
    def __init__(self, name, old):
        self.__name = name
        self.__old = old

    def get_old(self):
        return self.__old

    def set_old(self, old):
        self.__old = old

    old = property(get_old, set_old)
    """
    Из каждого экземпляра класса мы можем обращаться к атрибуту old класса. Этот атрибут является объектом property.
    Этот объект так устроен, что при считывании данных (a = p.old), то автоматически будет вызван геттер, который мы
    указали первым аргументом (важно: нужно передать ссылку на функцию, а не саму функцию). А когда идёт запись
    данных (p.old = 35), то автоматически вызывается сеттер, который мы указали вторым аргументом. В результате мы 
    через один атрибут класса old можем считывать данные из приватного свойства __old или записывать данные в это же 
    приватное локальное свойство. Это удобно тем, что не нужно запоминать имена всех геттеров и сеттеров для каждого 
    свойства класса.
    """


p = Person('Dima', 22)
p.old = 35  # раньше мы записали бы так: p.set_old(35).
print(p.old)  # раньше мы записали бы так: print(p.get_old()). Нового свойства не создаётся из-за приоритета: если в
# классе задан атрибут свойства (property), то в первую очередь выбирается именно оно, даже если в экземпляре класса
# есть локальное свойство с таким же именем.
print(p.__dict__)  # дополнительно проверяем изменения.

"""
Однако на данный момент наш класс выше имеет повторения (внутри property уже есть и геттер, и сеттер), так что на 
практике более лучшим решением будет использование property в качестве декоратора. Читаемость кода будет всё такой же, 
но мы избежим ненужного повторения, а так же уберём "прямые" сеттеры и геттеры. 
"""


class NewPerson:
    def __init__(self, name, old):
        self.__name = name
        self.__old = old

    @property  # Важно: ставить декоратор property нужно обязательно над геттером
    def old(self):  # Меняем имя с get_old на old для упрощения чтения. В последующих функциях тоже.
        return self.__old

    @old.setter
    def old(self, old):
        self.__old = old

    @old.deleter
    def old(self):
        del self.__old


np = NewPerson('Sasha', 16)
del np.old
print(np.__dict__)  # Удалено свойство old.
np.old = 20
print(np.__dict__)  # Снова создали приватное свойство old.
