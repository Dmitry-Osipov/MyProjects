from abc import ABC

"""
Принципы SOLID.
S - Single Responsibility Principle (принцип единственной ответственности)
O - Open-Closed Principle (принцип открытости-закрытости)
L - Liskov Substitution Principle (принцип подстановки Барбары Лисков)
I - Interface Segregation Principle (принцип разделения интерфейса)
D - Dependency Inversion Principle (принцип инверсии зависимостей)

Если говорить в двух словах, то эти принципы помогают нам правильно построить архитектуру программы, чтобы её легко было
модифицировать, развивать, программа была бы модульной, легко воспринимаемой. И естественно, эти принципы используются
для создания сложного проекта. Если в программе всего 2-3 класса, то принципы SOLID вообще не нужны. То, о чём мы будем
говорить далее касаются больших проектов, в которых задействовано 10-20 классов, которые должны как-то ещё существовать
с новыми добавляемыми классами. А также когда функционал проекта может расширяться. По-хорошему, программу следует
создавать так, чтобы не менять, не модифицировать заранее написанный код, но при этом иметь возможность расширять его
функционал. Как раз для этого и следует продумывать архитектуру программы, с чем могут помочь принципы SOLID. Причём эти
принципы - это не строгие правила, это лишь рекомендации - как следует делать.
Повторимся: следует использовать все 5 принципов только для больших проектов, ибо в маленьком проекте они мало чем
смогут помочь. Приступим.
"""

"""
Рассмотрим принцип единственной ответственности. Этот принцип о том, что каждый класс при разработке того или иного
проекта должен выполнять строго обозначенную функцию, т.е. ограничен только своей задачей. Не надо перегружать классы
огромным разным функционалом, создавая божественный класс. Рассмотрим пример нарушения, а потом рассмотрим, как его 
можно исправить:
"""


class Computer:
    def __init__(self, name: str, memory_size: int):
        self.name = name
        self.memory_size = memory_size

    def save(self):
        print('Сохранение объекта класса в файл')

    def load(self):
        print('Загрузка данных объекта из файла')


comp = Computer('IBM XT', 80000)
comp.save()

"""
Вроде бы мы создали удобный класс, который сохраняет и загружает данные в файле. Но по факту мы нарушили первый принцип:
принцип единственной ответственности - нарушение в том, что класс представляет не только объект (компьютер), но ещё и 
берёт на себя роль (задачу) по сохранению данных и по загрузке данных. На первый взгляд проблем не видно, но в будущем 
может возникнуть такая ситуация, что объект класса Computer нам придётся сохранять не только в файл, но ещё и в базу 
данных или в облако и т.д. Т.е. при смене способа сохранения данных в то или иное хранилище, то неминуемо придётся 
переписывать сам класс Computer, что и является плохим.
Как это можно исключить? Пусть класс Computer отвечает за представление самого компьютера, а роль сохранения данных, 
загрузки данных пусть берут на себя другие классы. И тогда при смене типа хранилища придётся менять другие классы, а не 
этот, который отвечает только за представление данных о компьютере. В этом и заключается идея единой ответственности - 
класс должен выполнять строго ту роль, которая ему отведена. Но это является тонким вопросом - роль класса. Ибо когда мы 
разрабатываем тот или иной проект определить для каждого класса его конкретную роль - это в целом искусство, и в каждой
задаче эта роль может быть разной.
К слову, был бы проект простым, то можно оставить этот класс так, как он есть сейчас. Но мы создадим отдельный класс для 
функций загрузки/выгрузки данных:
"""


class Computer:
    def __init__(self, name: str, memory_size: int):
        self.name = name
        self.memory_size = memory_size


class SaveComputer:  # Создаём отдельный класс, который выполняет функции сохранения файла в файл/базу данных.
    def save_to_file(self, path: str, computer: object):
        print(f'Сохранение в файл {path} на {computer}')

    def save_to_db(self, path: str, computer: object):
        print(f'Сохранение в базу данных {path} на {computer}')


comp = Computer('IBM XT', 80000)
saver = SaveComputer()
saver.save_to_file('out.dat', comp)

"""
Итак, мы реализовали принцип единственной ответственности: один класс представляет сам компьютер, а второй класс 
отвечает за методы сохранения информации.

Далее рассмотрим принцип открытости-закрытости. Этот принцип предполагает, что классы должны быть закрыты для 
модификации, но открыты для расширения. Что это значит? Вернёмся к классу SaveComputer - он нарушает принцип 
открытости-закрытости, ибо если мы захотим добавить функционал, который сохранял бы объекта класса в облако, то надо 
было бы добавить ещё один метод, который бы это делал. Т.е. нам бы пришлось модифицировать ранее написанный класс, чтобы
добавить новый функционал. А нам требуется писать классы так, чтобы классы не приходилось менять при добавлении нового 
функционала. Но как нам этого добиться? Нам помогут полиморфизм и абстрактные классы. Попробуем же исправить наш класс:
"""


class SaveInterface(ABC):  # Создали абстрактный класс, который будет сохранять данные. Далее нам требуется создать
    # отдельно класс более узкоспециализированный.
    def save(self, path: str, computer: object):
        print(f'Сохранение данных')


class SaveComputerToFile(SaveInterface):  # Появился новый класс, который отвечает только за сохранение информации в
    # файл, для сохранения в базу данных надо создать другой класс.
    def save(self, path: str, computer: object):
        print(f'Сохранение в файл {path} на {computer}')


class SaveComputerToDB(SaveInterface):  # Теперь мы получили разные классы, независимые между собой. Теперь при
    # необходимости сохранения информации в другие места, мы просто можем создать новые классы, т.е. менять ранее
    # написанные классы не придётся.
    def save(self, path: str, computer: object):
        print(f'Сохранение в базу данных {path} на {computer}')


saver = SaveComputerToFile()
saver.save('out.dat', comp)
saver = SaveComputerToDB()
saver.save('out.dat', comp)  # Теперь происходит автоматическая смена места сохранения, которая реализуется
# простой сменой класса в переменной.

"""
Ещё раз: принцип открытости-закрытости о том, что существующий уже написанный класс не нужно модифицировать для того, 
чтобы добавить новый функционал и часто это делается через абстрактные классы + полиморфизм (переопределение в дочерних 
классах методов родительских классов является полиморфизмом).

Следующий принцип подстановки Барбары Лисков гласит: подклассы должны заменять свои базовые классы. Это означает 
буквально следующее: если у нас есть какой-либо дочерний класс, то он должен полностью повторять функционал своего 
базового класса. Т.е. мы можем через дочерний класс вызвать любой метод базового класса и ожидать от этого метода точно 
такого же поведения, какое у него было, если мы его вызываем непосредственно из базового класса. Т.е. методы дочерних
классов должны реализовывать ту же логику работы, что и была в базовом классе. Т.е. существенно нельзя менять логику 
работы методов в дочерних классах. Рассмотрим нарушение данного принципа:
"""


class Computer:
    def __init__(self, name: str, memory_size: int):
        self.name = name
        self.memory_size = memory_size

    def set_data(self, name: str):
        self.name = name


class OmenHP(Computer):
    def __init__(self, name: str, memory_size: int):
        super().__init__(name, memory_size)

    def set_data(self, name):
        self.name = name
        self.memory_size = 2000


comp = Computer('IBM XT', 5000)
comp.set_data('Hello')
hp = OmenHP('Omen HP', 12000)
hp.set_data('World')
print(comp.__dict__, hp.__dict__)

"""
Почему теперь дочерний класс OmenHP нарушает принцип подстановки Барбары Лисков? Потому что метод set_data меняет 
поведение программы. Если вызывать метод set_data из базового класса, то мы меняем только имя, а если же его вызывать из
дочернего класса, то вместе с именем он изменит ещё и память. К чему это может привести:
"""


def test():
    comp = Computer('IBM XT', 5000)
    comp2 = OmenHP('Omen HP', 5000)
    comp2.set_data('IBM XT')  # Вызываем метод set_data уже зная, как он работает в базовом классе (представим, что
    # дочерний класс разрабатывал другой программист, а мы лишь пользуемся его классом).

    if comp.name == comp2.name and comp.memory_size == comp2.memory_size:
        print('Test ok')
    else:
        print('Test fail')


test()  # Тест не прошёл. И программист, не знающий, как определён дочерний класс, будет вынужден потратить время на
# отлов бага.

"""
Опять же, если задача требует изменения поведения функции, то можно переопределить её. Но всё же не стоит, ибо 
рекомендации на то и существуют, чтобы делать жизнь проще.

Следующий принцип разделения интерфейса гласит: нужно создавать узкоспециализированные интерфейсы, предназначенные для 
конкретного клиента, клиенты не должны зависеть от интерфейсов, которые они используют. Рассмотрим принцип детальнее на 
рисовании различных геометрических фигур:
"""


class Shape(ABC):
    def draw_line(self):
        pass

    def draw_circle(self):
        pass

    def draw_rect(self):
        pass


class Line(Shape):
    def draw_line(self):
        print('Рисование линии')

    def draw_circle(self):
        pass

    def draw_rect(self):
        pass


class Circle(Shape):
    def draw_line(self):
        pass

    def draw_circle(self):
        print('Рисование круга')

    def draw_rect(self):
        pass


class Rectangle(Shape):
    def draw_line(self):
        pass

    def draw_circle(self):
        pass

    def draw_rect(self):
        print('Рисование прямоугольника')


"""
По итогу мы создали не самую удобную конструкцию (для наглядности оставил все 3 функции в том порядке и с той логикой, 
которую получают дочерние классы от базового при наследовании). В каждом классе мы используем лишь 1 метод, а определены 
в каждом дочернем классе сразу все, хотя большинство этих методов и ненужны.
Принцип разделения интерфейсов как раз и говорит о том, что не надо создавать множество интерфейсов, которые реализуют 
огромное количество методов. Лучше создать множество более специализированных интерфейсов, дабы не порождать таких 
проблем. Выйти из ситуации просто: в абстрактном классе оставим лишь 1 общий метод:
"""


class ILine(ABC):
    def draw_line(self):
        print('Рисование линии')


class ICircle(ABC):
    def draw_circle(self):
        print('Рисование круга')


class IRectangle(ABC):
    def draw_rect(self):
        print('Рисование прямоугольника')


class Line(ILine):
    def draw_line(self):
        print('Рисование линии')


class Circle(ICircle):
    def draw_circle(self):
        print('Рисование круга')


class Rectangle(IRectangle):
    def draw_rect(self):
        print('Рисование прямоугольника')


line = Line()
line.draw_line()
circle = Circle()
circle.draw_circle()
rect = Rectangle()
rect.draw_rect()

"""
Вот теперь мы избавились от лишних методов внутри одного класса, которые ещё и требовалось переопределять в каких-то 
дочерних классах. Соответственно, лучшим решением является создание узкоспециализированных интерфейсов.

Пятый принцип инверсий зависимостей гласит: наши классы должны зависеть от интерфейсов или абстрактных классов, а не от 
конкретных классов и функций. Рассмотрим на конкретном примере: 
"""


class ModelForm:
    def __init__(self, id: int, old: int, fio: str):
        self.id = id
        self.old = old
        self.fio = fio


# Далее опишем класс, который опишет сам фреймворк, и класс для базы данных:


class MySQL:
    def save(self, frm: object):
        print('Запись формы в базу данных')


class WebFramework:
    def save(self, frm: object):
        db = MySQL()
        db.save(frm)


f = ModelForm(1, 30, 'Осипов Д.Р.')
w = WebFramework()
w.save(f)

"""
В итоге у нас получились 3 класса для всей истории: класс модели, класс фреймворка и класс базы данных. Что в этом 
плохого, и почему эти 3 класса будут нарушать принцип инверсии зависимостей?
Классы WebFramework и MySQL завязаны напрямую с классом ModelForm. А таких классов Form может быть множество, и по идее 
классы WebFramework и MySQL должны работать со всеми Form. Т.е. в методе save этих классов нужно определить какой-то 
абстрактный по классу ModelForm:
"""


class IForm(ABC):
    def __init__(self, id: int, old: int, fio: str):
        self.id = id
        self.old = old
        self.fio = fio


class ISQL(ABC):  # Аналогично следует в качестве абстрактного класса указать базу данных, ибо есть множество их
    # вариантов, а не только одна-единственная MySQL.
    def save(self, frm: object):
        print(f'Запись {frm} в базу данных')


class WebFramework:
    def save(self, frm: object):
        db = MySQL()
        db.save(frm)
