class Geom1:
    name = 'Geom'


class Line1:
    def draw(self):
        print('Рисование линии')


g1 = Geom1()
print(g1.name)  # Спокойно выводим имя класса.
# print(g.draw())  # Но не можем вывести метод draw, ибо метод относится к другому классу.
l1 = Line1()
l1.draw()  # Соответственно, создав экземпляр класса Line, можно спокойно вывести метод draw().

"""
Из этого вывод class Geom и class Line - это 2 совершенно разных пространства имён, 2 разных класса. Но при
необходимости можно установить связь между ними. Например, сделать так, чтобы открытые атрибуты класса Geom были 
доступны классу Line. Записывается такая связка следующим образом:
"""


class Geom2:
    name = 'Geom'


class Line2(Geom2):
    """
    За скобками прописываем, какой класс хотим расширить (в данном случаем Line), в скобках - каким классом хотим
    расширить (в данном случае Geom). Такая конструкция, когда один класс определяется на основе другого называется
    Наследованием. Класс Geom называется базовым (или родительским), а класс Line - подклассом (или дочерним классом).
    Графически это изображается прямоугольниками. Причём стрелка будет направлена от дочернего класса к родительскому.
    Для чего может понадобиться наследование? Добавим в класс Line метод set_coords(), а после определим подобный класс
    Line'у, который будет отвечать за прямоугольники:
    """
    def draw(self):
        print('Рисование линии')

    def set_coords(self, x1, y1, x2, y2):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2


g2 = Geom2()
l2 = Line2()
print(l2.name)  # Теперь мы можем спокойно обратиться к атрибуту name класса Geom.


class Rect2(Geom2):
    """
    В итоге получили 2 класса Rect и Line, и в этих двух классах получилось дублирование кода в методе set_coords().
    Данное дублирование будет нарастать с увеличением количества классов геометрических фигур. Чтобы это избежать, мы
    можем общий для всех дочерних классов код вынести в базовый.
    """
    def draw(self):
        print('Рисование прямоугольника')

    def set_coords(self, x1, y1, x2, y2):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2


# ----------------------------------------------------------------------------------------------------------------------


class Geom:
    name = 'Geom'

    def set_coords(self, x1, y1, x2, y2):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2


class Line(Geom):
    name = 'Line'
    def draw(self):
        print('Рисование линии')


class Rect(Geom):
    def draw(self):
        print('Рисование прямоугольника')


g = Geom()
l = Line()
r = Rect()
g.set_coords(0, 0, 0, 0)
l.set_coords(1, 1, 2, 2)
r.set_coords(2, 2, 3, 3)
print(g.__dict__)
print(l.__dict__)
print(r.__dict__)

print(l.name, r.name)

"""
Таким образом, мы создали иерархию, где Line и Rect наследуются у Geom. При вызове метода set_coords() он сначала ищется
в дочернем классе (Line или Rect), если его там нет, как в нашем случае, то поиск продолжается в базовом классе (Geom).
В базовом классе метод нашёлся и выполнился. Причём параметр self метода set_coords() будет ссылаться на объект 
дочернего класса, т.е. это ссылка на объект l. Это важно понимать: параметр self в базовых классах может ссылаться 
не только на объекты этого же класса, но и на объекты дочерних классов, если метод (в нашем случае set_coords()) был 
вызван через объект дочернего класса. Таким образом, всё зависит, откуда вызывается метод. Если он вызван из объекта
родительского класса, то параметр self ссылается на родительский класс, а если вызван изобъекта дочернего, то self 
ссылается на дочерний класс. 

Это важно потому, что параметр self формирует локальные свойства именно для объектов дочерних классов (в нашем случае - 
x1, y1, x2, y2). По такой же логике можно прописать в методе set_coords() вызов метода draw() из дочерних классов, и в 
консоли мы увидим вывод: 
"Рисование линии 
Рисование прямоугольника" -
Т.е. в объекте класса Line и Rect был вызван метод draw() (сам метод вызывается в базовом классе), который и отобразил 
рисование линии - и всё сработало через параметр self. 
Однако так делать (вызывать метод в родительском классе из дочерних) не стоит, ибо он таит в себе потенциальную 
опасность, ибо если создать экземпляр базового класса и вызвать метод set_coords() (через базовый класс), то выскочит 
ошибка AttributeError (ибо метод draw в родительском классе реализован не был).

Таким образом, требуется придерживаться базового правила: Вызывать внутри базового метода следует те методы - другие 
методы -, которые определены в этом же базовом классе или в уже его базовых классах, но не в дочерних.

Похожим образом происходит и обращение к свойствам базовых классов. Сейчас в базовом классе есть свойство name, и мы 
можем к нему обратиться через объекты дочерних классов. Т.е. когда происходит обращение к какому-либо атрибуту, то 
сначала этот атрибут ищется в соответствущем дочернем классе (в нашем случае Line или Rect). А если его там нет, то 
поиск продолжается в базовом классе (в нашем случае Geom). Соответственно, если в классе Line определить атрибут 
name = 'Line', то при вызове атрибута (print(l.name)) мы увидим в консоли Line.
Когда мы определяем заново атрибут в дочернем классе, который уже есть в базовом классе, то это называется 
переопределением атрибута, что и покажет IDE (кружок и стрелка вверх). А в базовом классе мы увидим кружок и 
стрелку вниз, что говорит о переопределении атрибута в дочернем классе. Аналогично с методами.
В свою очередь, мы также видим кружок и стрелочку вниз около базового класса, когда от него наследуются дочерние классы 
(IDE так же подскажет, в каких классах продолжает своё наследование родительский класс).
"""


