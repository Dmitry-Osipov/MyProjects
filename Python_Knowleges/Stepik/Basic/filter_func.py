"""
filter(func, *iterables) - фильтрация элементов итерированного объекта.
Работает таким образом: если func возвращает True, то элемент учитывается в filter, если func возвращает False, то
элемент пропускается. Рассмотрим конкретнее:
"""

a = [x for x in range(1, 11)]
b = filter(lambda x: x % 2 == 0, a)
print(b)  # Видим объект filter, который на самом деле является итератором.
print(*b)  # При распаковке получаем: 2 4 6 8 10.

"""
Полученный filter-итератор можно преобразовать с помощью нужной нам функции: tuple, set, max, sum и т.д.

Но иногда требуется совершать сложную операцию по фильтрации. Допустим, нас интересуют только простые числа:
"""


def is_simple(x):
    d = x - 1
    if d < 0:
        return False

    while d > 1:
        if x % d == 0:
            return False

        d -= 1

    return True


b = filter(is_simple, a)
print(tuple(b))

"""
Естественно, фильтрацию можно проводить не только на цифрах, вот к примеру кортеж строк, в котором нас интересуют города
только с буквенными символами:
"""

cities = ('Москва', 'Рязань1', 'Смоленск', 'Тверь2', 'Томск')
b = filter(str.isalpha, cities)
print(list(b))

"""
Т.к. функция filter вторым аргументом принимает любой итерируемый объект, то мы можем передать туда и функцию. К примеру 
первая функция будет отбирать только простые числа, а вторая только нечётные:
"""

a = [x for x in range(1, 11)]
b = filter(is_simple, a)
c = filter(lambda x: x % 2 != 0, b)
print(list(c))

"""
Однако не стоит городить фильтр на фильтре. Порой гораздо лучше создать 1 сложную функцию и передавать ссылку на неё в 
filter.
"""
