"""
Функция zip(iter1 [, iter2 [, iter3 ...]) выполняет перебор соответствующих элементов и продолжает до тех пор, пока не
дойдёт до конца самой короткой коллекции:

1  2  3  4
5  6  7  8  9 10
11 12 13 14 15

|
V

(1, 5, 11), (2, 6, 12), (3, 7, 13), (4, 8, 14)
"""

a = [1, 2, 3, 4]
b = [5, 6, 7, 8, 9, 10]
z = zip(a, b)
print(z)  # Получаем объект zip - итератор.

for tp in z:
    print(tp)  # Получили все кортежи значений. Функция перебрала до самой короткой и завершилась без ошибки.

c = 'python'

z = zip(a, b, c)
for tp in z:
    print(tp)  # Можно принимать разные типы данных, главное, чтобы они были итерируемыми.

"""
Т.к. мы получаем кортежи, то их можно и сразу распаковать:
"""

z = zip(a, b, c)
for q, w, e in z:
    print(q, w, e)

z1, z2, z3, z4 = zip(a, b, c)  # 4 кортежа внутри zip записываем в 4 переменные (нужно записывать ровно столько).
print(z1, z2, z3, z4)

z = zip(a, b, c)
z1, *z2 = zip(a, b, c)
print(z1, z2)  # В крайнем случае можно упаковать значения в список.

z = zip(a, b, c)
lz = list(z)  # Получим[(1, 5, 'p'), (2, 6, 'y'), (3, 7, 't'), (4, 8, 'h')]
new_z = zip(*lz)
print(*new_z)  # Получили (1, 2, 3, 4) (5, 6, 7, 8) ('p', 'y', 't', 'h'), т.к. перебирали каждый кортежи по очереди.

"""
Хотя проще переписать её без использования списков:
"""

z = zip(a, b, c)
new_z = zip(*z)
print(*new_z)  # Получаем в итоге то же самое.
