"""
С Python 3.10 появилась конструкция match/case, которая позволяет гибко анализировать переменные на соответствие
шаблонам, и для найденного совпадения выполнять некие операции.

match <переменная>:
    case <шаблон_1>:
        операторы
    ...
    case <шаблон_n>:
        операторы
    case _:
        иначе (default)

Запишем конструкцию в самом простом варианте:
"""

cmd = 'right2'

match cmd:
    case 'top' | 'down':
        print('Вверх или вниз')
    case 'left':
        print('Влево')
    case 'right':
        print('Вправо')
    case _:  # wildcard
        print('Другое')

print('Проверки завершены')

"""
Как только один из блоков case отработал, то оператор match завершает работу, после чего переходит к следующему 
выполнению программы.
Допустимым является реализация хотя бы одного блока case, общее количество же может быть 
произвольным (конечно, следует помнить о читаемости программы). 
Внутри каждого блока case должен быть хотя бы 1 оператор. Если операторов не будет, то мы ошибку:
IndentationError: expected an indented block after 'case' statement on line 24.
Если в одном блоке case требуется определить несколько констант, то это делается через оператор "|". Количество констант 
в таком случае должно быть не менее 2.

Данный оператор похож на switch/case для Java или C++, но является более универсальным засчёт того, что в case мы 
прописываем не просто константу, а целый шаблон:
"""

match cmd:
    case command:
        print(f'Команда {command}')

"""
Всё отработало, но как?
Как только после блока case мы прописываем какую-либо переменную, то у нас в программе создаётся переменная с этим 
именем (если её ранее не было в программе), и она будет ссылаться на то же самое значение, что и переменная cmd.
Причём такой case будет срабатывать всегда, ибо он не делает никаких проверок, а просто создаёт переменную, присваивает
ей значение и отрабатывает соответствующую операцию. Если попытаться прописать другой блок case: ... в нашем варианте, 
то получим исключение: SyntaxError: name capture 'command' makes remaining patterns unreachable. Т.е. если мы хотим 
отработать несколько case при нашем case command: ..., то нам требуется прописать все нужные case до блока case command.
Грубо говоря, если провести аналогию с if-elif-else, то наш блок case command - это else, а else сразу прописать нельзя.
Соответственно, если вместо command прописать _ (case _: ...), то мы получим тот же результат, который отрабатывает 
всегда, если другие блоки case не отработали.

Усложним задачу: будем проверять, является ли cmd строковым типом данных:
"""

match cmd:
    case str():  # Строго обязательно с круглыми скобками.
        print('Тип данных - строка')
    case _:
        print('Неопределённый тип данных')

"""
А если нам нужно не только определить строку, но и сформировать новую переменную, которая будет ссылаться на эту строку?
Это возможно сделать через конструкция as:
"""

match cmd:
    case str() as command:  # Вначале идёт проверка строкового типа, если True, то только после этого создаётся переменная.
        print(f'Строковая команда: {command}')
    case _:
        print('Другая команда')

match cmd:
    case str(command):  # Эта запись аналогична записи выше, но она несколько запутана, так что лучше писать с as.
        print(f'Строковая команда: {command}')
    case _:
        print('Другая команда')

cmd = True

match cmd:
    case str() as command:
        print(f'Строковая команда: {command}')
    case int() as command:
        print(f'Целочисленная команда: {command}')
    case bool() as command:
        print(f'Белева-команда: {command}')
    case _:
        print('Другая команда')

"""
По итогу получаем вывод: Целочисленная команда: True. Так произошло потому, что проверка на тип данных происходит по 
типу проверки функцией isinstance(). Класс bool наследуется от класса int, так что мы увидели такой вывод. Разрешить эту
проблему просто: т.к. шаблоны проверяются сверху вниз, то шаблон bool должен быть выше шаблона int.

Далее усложним: предположим что для целых чисел мы должны проверять число на соответствие промежутку [0;9]:
"""

cmd = 1

match cmd:
    case str() as command:
        print(f'Строковая команда: {command}')
    case bool() as command:
        print(f'Булева-команда: {command}')
    case int() as command if 0 <= command <= 9:  # Попадая в это условие, мы можем быть уверены в отсутствии исключений.
        print(f'Целочисленная команда: {command}')
    case _:
        print('Другая команда')

"""
Допустим, мы хотим обрабатывать информацию в виде кортежа или списка. Ниже пример с кортежем. Т.к. кортеж относится к 
упорядоченным типам данных - Sequence Types (tuple, list, range) - то мы можем распаковывать кортежи в операторах case.
Внимание: множества, строки, словари не являются Sequence Types. Соответственно, ни один case ниже для них не сработает.
"""

cmd = ('Осипов Д.Р.', 'Python', 2000.78)

match cmd:
    case author, title, price:  # Фактически идёт такая распаковка по переменным: author, title, price = cmd.
        print(f'Книга: {author}, {title}, {price}')  # Причём такой кейс отработает если в кортеже ровно 3 элемента.
    case _:
        print('Непонятный формат данных')

# Однако если нам нужно распаковать кортеж/список из более 3 элементов, то можно использовать оператор * с _, где _
# говорит о том, что нам не нужны последующие данные:

cmd = ['Осипов Д.Р.', 'Python', 2000.78, 2023, 385]

match cmd:
    case (str() as author, str() as title, int() | float() as price, *_) if len(cmd) < 6:  # Чтобы шаблон был более
        # читабельным, то следует использовать группирующие скобки: либо (), либо [].
        print(f'Книга: {author}, {title}, {price}')  # И даже если элемента всего 3, то всё спокойно отработает.
    case _:  # Соответственно, если элементов будет меньше 3, то отработает отбойник.
        print('Непонятный формат данных')

"""
Допустим, у нас идёт несколько форматов данных: привычный нам выше, и когда сначала идёт id. Т.е. он может стоять, а 
может и не стоять. Как это сделать:
"""

cmd = ('Осипов Д.Р.', 'ООП', 5500)
cmd = [1, 'Осипов Д.Р.', 'Python', 2000.78, 2023]

match cmd:
    case [author, title, price]:
        print(f'Первая книга: {author}, {title}, {price}')
    case [_, author, title, price, _]:
        print(f'Вторая книга: {author}, {title}, {price}')
    case _:
        print('Непонятный формат данных')

# В таком варианте у нас идёт дублирование кода. Избежать этого можно, объединив оба кейса в один шаблон.

match cmd:
    case tuple():  # Допустим, мы не хотим обрабатывать кортежи.
        print('Неверный формат данных - кортеж')
    case (author, title, price) | (_, author, title, price, _):  # Однако нюанс в том, что переменные двух шаблонов
        # должны одинаково называться, а также кол-во переменных должно совпадать. Т.е. если количество или именование
        # переменных отличается, то нужно использовать два case.
        print(f'Книга: {author}, {title}, {price}')
    case _:
        print('Непонятный формат данных')

"""
Пришла очередь обрабатывать словари и множества. Начнём со словарей. Допустим в блок обработки поступает словарь, откуда
мы хотим получить значения по ключам:
"""

request = {'url': 'https://proproprogs.ru/', 'method': 'GET', 'timeout': 2000, }

match request:  # Наличие других ключей не играет вообще никакой роли, т.е. в словарях нам важно только присутствие
    # определённых ключей.
    case {'url': url, 'method': method, }:  # По ключу url забираем значение url из словаря, аналогично с method.
        print(f'Запрос: url: {url}, method: {method}')
    case _:
        print('Неверный запрос')

# Также можно внести проверку на тип данных для значений:

match request:
    case {'url': str() as url, 'method': str(method), 'timeout': 1000 | 2000}:  # Дополнительно поставили условие:
        # если значение timeout будет 1000, то выводится запрос. Также можно указать 2 значения через |.
        # Либо можно указать 2 кейса с этим оператором, но это будет избыточной записью.
        print(f'Запрос: url: {url}, method: {method}')
    case _:
        print('Неверный запрос')

# Представим, что нам нужно обрабатывать только те словари, где не более 3 ключей:

match request:
    case {'url': str() as url, 'method': str(method)} if len(request) <= 3:
        print(f'Запрос: url: {url}, method: {method}')
    case _:
        print('Неверный запрос')

# Предположим, что нам нужно построить шаблон проверки словаря, в котором есть ключи url, method , и дополнительно может
# быть не более двух ключей:

match request:
    case {'url': str() as url, 'method': str(method), **kwargs} if len(kwargs) <= 2:  # Т.к. мы работаем со словарями,
        # то используем оператор ** и привычный аргумент kwargs.
        print(f'Запрос: url: {url}, method: {method}')
    case _:
        print('Неверный запрос')

# Аналогичным методом можно описать шаблон, когда нам нужно, чтобы мы выводили запись только в тех случаях, когда в
# словаре присутствуют только два нужных нам аргумента:

match request:
    case {'url': url, 'method': method, **kwargs} if not kwargs:  # Причём неважно, где расположены эти kwargs в словаре
        print(f'Запрос: url: {url}, method: {method}')
    case _:
        print(f'Есть дополнительные пары в словаре: {kwargs}')

# Усложним структуру словаря, причём ключ data принимает список, если ключ type == list:

json_data = {'id': 2, 'type': 'list', 'data': [1, 2, 3], 'access': True, 'date': '01.01.2023', }

match json_data:
    case {'type': 'list', 'data': list() as lst}:  # Можем усовершенствовать шаблон, так что теперь он работает, когда
        # type == list и тип данных для data действительно являются списком
        print(f'JSON-данные: type-list: {lst}')
    case _:
        print(f'Неверный запрос')

# Рассмотрим пример с более сложным словарём. Требуется проверить наличие ключей access и ключа info. Из ключа info
# выделить значение email:

json_data = {'id': 2, 'access': True, 'info': ['01.01.2023', {'login': '123', 'email': 'email@m.ru'}, True, 1000]}

match json_data:
    case {'access': access, 'info': [_, {'email': email}, *_]}:
        print(f'JSON-данные: access: {access}, email: {email}')
    case _:
        print('Неверный запрос')

"""
Теперь разберёмся с работами со множествами. Не получится прописывать {a, b, c}, ибо ожидаются данные в формате 
ключ-значение. Если требуется работать со множествами, то в шаблоне необходимо определить проверку на тип данных, дать
имя для переменной. При необходимости можно прописать гард. А все операции со множествами должны проходить уже внутри 
блока case.
"""

primary_case = {1, 2, 3}

match primary_case:
    case set() as keys if len(keys) < 5:
        print(f'Primary case: {primary_case}')

"""
Предположим, что нам требуется организовать подключение к базе данных, для чего формируется словарь с необходимыми 
данными. Далее с помощью функции будем выполнять проверку данных в запросе, и если всё хорошо, то возвращаем результат 
подключения.
"""


def connect_db(connect: dict) -> str:
    match connect:
        case {'server': host, 'login': login, 'password': psw, 'port': port}:
            return f'Connection: {host}@{login}.{psw}:{port}'
        case {'server': host, 'login': login, 'password': psw}:  # Если порта нет, то назначаем порт по умолчанию.
            port = 22
            return f'Connection: {host}@{login}.{psw}:{port}'
        case _:
            return 'Error connection'


"""
Всё отработало верно, но бросается в глаза дублирование кода. Причём полное дублирование возврата. Нашу функцию можно 
улучшить: в первом case прописать оператором pass (тогда при всех условиях мы просто выйдем из match), во втором 
оставим только присваивание порта, а третий трогать не будем. И по итогу вернём нужное значение функции в самом конце:
"""


def connect_db(connect: dict) -> str:
    match connect:
        case {'server': host, 'login': login, 'password': psw, 'port': port}:
            pass
        case {'server': host, 'login': login, 'password': psw}:
            port = 22
        case _:
            return 'Error connection'

    return f'Connection: {host}@{login}.{psw}:{port}'  # Видим, что переменные, созданные в шаблоне, существуют и вне
    # конструкции match/case.


request = {'server': '127.0.0.1', 'login': 'root', 'password': '1234', 'port': 24, }

result = connect_db(request)
print(result)

"""
Теперь рассмотрим пример, когда информация о книгах может существовать в форматах разных данных. Требуется сформировать 
функцию, которая на выходе при передаче таких данных формирует кортеж в виде: (автор, название, год, цена). Причём при 
отсутствии каких-то значений, то вместо него записывается значение None.
"""


def book_tot_tuple(data: dict | tuple | list) -> tuple | None:
    match data:
        case author, title, year:  # При количестве переменных != 3 перейдёт дальше.
            price = None
        case author, title, year, price, *_:  # Проводим распаковку списка/кортежа.
            pass
        case {'author': author, 'title': title, 'year': year, 'price': price, }:  # Получаем значения для "полного" словаря.
            pass
        case {'author': author, 'title': title, 'year': year, }:  # Получаем значения для "неполного" словаря. Прописываем
            # последним, ибо если в словаре есть price, то он будет перезаписан (т.к. данный шаблон более общий).
            price = None
        case _:  # В других случаях ничего не возвращаем.
            return None

    return author, title, year, price


"""
Всё работает, но мы имеем небольшое дублирование кода при price = None. Исправим это, вынеся price до match. Потому что
если вдруг по каким-то причинам эта переменная не будет сформирована, то она по умолчанию будет ссылаться на None, и 
тогда мы всегда будем возвращать нужный набор переменных.
"""


def book_tot_tuple(data: dict | tuple | list) -> tuple | None:
    price = None
    match data:
        case author, title, year:
            pass
        case author, title, year, price, *_:
            pass
        case {'author': author, 'title': title, 'year': year, 'price': price, }:
            pass
        case {'author': author, 'title': title, 'year': year, }:
            pass
        case _:
            return None

    return author, title, year, price


"""
Усложним задачу, сделав проверку на целочисленный тип данных для year и принадлежности этой переменной к параметрам, 
которые мы дополнительно передаём в функцию:
"""


def book_tot_tuple(data: dict | tuple | list, min_year=1800, max_year=3000) -> tuple | None:
    price = None
    match data:
        case author, title, int(year) if min_year <= year <= max_year:
            pass
        case author, title, int(year), price, *_ if min_year <= year <= max_year:
            pass
        case {'author': author, 'title': title, 'year': int(year), 'price': price, } if min_year <= year <= max_year:
            pass
        case {'author': author, 'title': title, 'year': int(year), } if min_year <= year <= max_year:
            pass
        case _:
            return None

    return author, title, year, price


"""
Однако мы снова получили дублирование кода. В таком случае целесообразно комбинировать оператор match с if:
"""


def book_tot_tuple(data: dict | tuple | list, min_year=1800, max_year=3000) -> tuple | None:
    price = None
    match data:
        case author, title, int(year):
            pass
        case author, title, int(year), price, *_:
            pass
        case {'author': author, 'title': title, 'year': int(year), 'price': price, }:
            pass
        case {'author': author, 'title': title, 'year': int(year), }:
            pass
        case _:
            return None

    if not (min_year <= year <= max_year):
        return None

    return author, title, year, price


book_1 = ('Осипов', 'Python', 2022)
book_2 = ['Осипов', 'Python ООП', 2022, 3432.77]
book_3 = {'author': 'Осипов', 'title': 'Нейросети', 'year': 2020, }
book_4 = {'author': 'Осипов', 'title': 'Keras + Tensorflow', 'price': 5430, 'year': 2020}

print(book_tot_tuple(book_1))
print(book_tot_tuple(book_2))
print(book_tot_tuple(book_3))
print(book_tot_tuple(book_4))

"""
Предположим, что мы имеем некую целочисленную переменную, и в конструкции match/case мы бы хотели выделить 2 ситуации:
переменная равна 3 и переменная равна 5:
"""

cmd = 10

match cmd:
    case 3:
        print(3)
    case 5:
        print(5)

"""
Но в идеале задать некие константы для 3 и 5, а далее их использовать:
"""

CMD_3 = 3
CMD_5 = 5

cmd = 5

# match cmd:
#     case CMD_3:  # Но мы получаем ошибку SyntaxError: name capture 'CMD_3' makes remaining patterns unreachable
#         print(3)
#     case CMD_5:
#         print(5)

"""
Дело в том, что в Python как таковых констант нет, а CMD_3 и CMD_5 на самом деле обычные переменные, которые мы указываем
после оператора case. В действительности это равносильно записи:

match cmd:
    case _: 
        print(3)
    case CMD_5:  # До сюда программа банально не дойдёт
        print(CMD_5)
        
Но если закомментировать/удалить case CMD_5, то всё будет работать, но с предупреждением от IDE. 
Но если нам всё же нужно использовать эти переменные - не просто же так мы их завели.
Есть минимум 2 способа.
1) если у нас есть константы, и они определены, а менять мы этого не хотим, то можно пойти на хитрость: в кейсе проверить
принадлежность cmd к int, обозначить её как x (или другое имя), а далее сравнить x и константу. Однако данная конструкция 
является большой, и проще было бы воспользоваться конструкцией if-elif-else.
2) Разработчики разрешили использовать переменные как константу после case, если перед переменной указана точка. Но что 
это значит? Это значит что переменная будет находиться в отдельном модуле. Тогда надо вынести константы в отдельный файл, 
импортировать его, и оттуда брать значения переменных.
Кстати, по аналогичной схеме можно засунуть константы в класс, откуда и брать их значения.
"""

match cmd:  # 1 вариант.
    case int(cmd) as x if x == 3:
        print(3)
    case int(cmd) as x if x == 5:
        print(5)


class Consts:
    CMD_3 = 3
    CMD_5 = 5


match cmd:  # 2 вариант.
    case Consts.CMD_3:  # Использован импортируемый файл или класс.
        print(3)
    case Consts.CMD_5:
        print(5)
