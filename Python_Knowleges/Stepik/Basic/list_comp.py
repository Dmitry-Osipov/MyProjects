# Сформируем список, состоящий из квадратов чисел:
N = 6
a = [0] * N
for i in range(N):
    a[i] = i ** 2

print(a)  # [0, 1, 4, 9, 16, 25]

# Всё отработало, но вот более лаконичный способ:
a = [number ** 2 for number in range(N)]
print(a)  # [0, 1, 4, 9, 16, 25] - Получили тот же вывод, но в одну строчку и быстрее.

"""
Синтаксис генератора списков в самом простом исполнении: 
[<способ формирование значения> for <значение> in <итерируемый объект>]
"""

a = [1 for x in range(5)]  # Важно заметить, что переменная х доступна только внутри генератора.
print(a)  # [1, 1, 1, 1, 1]

a = [x % 4 for x in range(N)]
print(a)  # [0, 1, 2, 3, 0, 1]

a = [x % 2 == 0 for x in range(N)]
print(a)  # [True, False, True, False, True, False]

a = [0.5 * x + 1 for x in range(N)]
print(a)  # [1.0, 1.5, 2.0, 2.5, 3.0, 3.5]

d_inp = input('Введите целые числа через пробел: ')
a = [int(d) for d in d_inp.split()]
print(a)  # [1, 2, 3, 4]

a = [d for d in 'python']
print(a)  # ['p', 'y', 't', 'h', 'o', 'n']

a = [ord(d) for d in 'python']
print(a)  # [112, 121, 116, 104, 111, 110]

"""
Синтаксис генератора списков в более сложном исполнении: 
[<способ формирование значения> for <значение> in <итерируемый объект> if <условие>]
"""

a = [x for x in range(-5, 5) if x < 0]
print(a)  # [-5, -4, -3, -2, -1]

a = [x for x in range(-5, 5) if x % 2 == 0]
print(a)  # [-4, -2, 0, 2, 4]

a = [x for x in range(-6, 7) if x % 2 == 0 and x % 3 == 0]
print(a)  # [-6, 0, 6]

cities = ['Москва', 'Тверь', 'Рязань', 'Ярославль', 'Владимир']
a = [city for city in cities if len(city) < 7]
print(a)  # ['Москва', 'Тверь', 'Рязань']

"""
Также внутри генератора списка можно использовать тернарный оператор:
"""

d = [4, 3, -5, 0, 2, 11, 122, -8, 9]
a = ['Чётное' if x % 2 == 0 else 'Нечётное' for x in d]
print(a)  # ['Чётное', 'Нечётное', 'Нечётное', 'Чётное', 'Чётное', 'Нечётное', 'Чётное', 'Чётное', 'Нечётное']

"""
Но такую конструкцию проще писать не в одну, а несколько строчек:
"""

a = ['Чётное' if x % 2 == 0 else 'Нечётное'
     for x in d
     if x > 0]
print(a)  # ['Чётное', 'Нечётное', 'Чётное', 'Нечётное', 'Чётное', 'Нечётное']

"""
Далее рассмотрим вложенные циклы в генератор списка:
"""

a = [(i, j) for i in range(3) for j in range(4)]
print(a)  # [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3)]

# Перепишем на то же самое, но в несколько строк:
a = [(i, j)
     for i in range(3)
     for j in range(4)]
print(a)  # [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3)]

"""
Более того, для каждого цикла можно прописывать своё отдельное условие:
"""

a = [(i, j)
     for i in range(3) if i % 3 == 0
     for j in range(4)]
print(a)  # [(0, 0), (0, 1), (0, 2), (0, 3)]

a = [(i, j)
     for i in range(3) if i % 3 == 0
     for j in range(4) if j % 2 == 0]
print(a)  # [(0, 0), (0, 2)]

# Используя такой подход, легко формировать таблицу умножения:
a = [f'{i} * {j} = {i * j}'
     for i in range(1, 3)
     for j in range(1, 4)]
print(a)  # ['1 * 1 = 1', '1 * 2 = 2', '1 * 3 = 3', '2 * 1 = 2', '2 * 2 = 4', '2 * 3 = 6']

# Преобразуем двумерный список в обычный одномерный:
matrix = [[0, 1, 2, 3],
          [10, 11, 12, 13],
          [20, 21, 22, 23]]
a = [x for row in matrix
     for x in row]  # Во вложенных циклах можно использовать переменные, объявленные в этом же генераторе.
print(a)  # [0, 1, 2, 3, 10, 11, 12, 13, 20, 21, 22, 23]

"""
Также внутри генератора списка можно использовать ещё один генератор списка:
"""

M, N = 3, 4
matrix = [[a for a in range(M)] for b in range(N)]
print(matrix)  # [[0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]
"""
Получили такой вывод, потому что вложенный генератор списка нам даёт список [0, 1, 2], а основной генератор по сути 
дублирует такой список 4 раза.
"""

A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
A = [[x ** 2 for x in row] for row in A]  # Удобной конструкцией возводим каждый элемент в квадрат.
print(A)  # [[1, 4, 9], [16, 25, 36], [49, 64, 81]]

"""
Почему нельзя воспользоваться нашей старой конструкцией:
"""

AA = [x ** 2 for row in A for x in row]
print(A)  # Должны были получить матрицу как эта: [[1, 4, 9], [16, 25, 36], [49, 64, 81]]
print(AA)  # Получили в итоге одномерный список: [1, 16, 81, 256, 625, 1296, 2401, 4096, 6561]

# Меняем все строки матрицы на столбцы (транспонируем матрицу):
a = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
A = [[row[i] for row in a] for i in range(len(a[0]))]
print(A)  # [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]

"""
Как у нас это получилось:

i
|
V
0 1 2 3
1 2 3 4
5 6 7 8
9 10 11 12

По своей сути row[0] - это [1, 5, 9], row[1] - [2, 6, 10], row[2] - [3, 7, 11], row[3] - [4, 8, 12], ибо row - это 
"ширина" (горизонтально), а i - это "высота" (вертикально), таким образом, изначально i = 0, соответственно row тоже 
пробегает только по первым элементам, получаем в итоге row[i] - это i-ый столбец матрицы.

Также мы можем засунуть генератор списка в in, ибо генератор списка - это тоже итерируемый объект, например:
g = [u ** 2 for u in [x+1 for x in range(5)]]
g(u(x+1)) = (x+1)^2
"""

g = [u ** 2 for u in [x+1 for x in range(5)]]
print(g)  # [1, 4, 9, 16, 25]
