"""
Пользовательский класс по умолчанию наследуется от базового класса object.
К примеру, если начать писать класс, не внести ни одной функции или переменной (class ...: pass), то бы обращении к нему
мы всё равно увидим множество функций. Все эти функции берутся из базового класса object (например, все магические
методы). Т.е. по факту объявление класса class ... будет аналогично такому объявлению: class ...(object). С версии
Python 3 такое наследование делается автоматически. Так сделано, чтобы обеспечить стандартный базовый функционал работы
с классами.
"""


class Geom:
    pass


g = Geom()
print(g)
"""
<__main__.Geom object at 0x000002BD083D51D0> - данная строчка появилась благодаря отработке в базовом классе
функции __str__. Таким образом, функционал print(g) существует благодаря наследованию. Но если добавить новый класс,
который наследуется от предыдущего, то цепочка наследования будет такой: Line -> Geom -> object. Т.е. указывая в
качестве базового класса, любой другой класс, непосредственное наследование от object у класса Line не происходит, а
наследуется Line только от класса Geom. Разумеется, объект класса Line будет иметь доступ ко всем атрибутам
класса object.
"""


class Line(Geom):
    pass


l = Line()
print(l.__class__)  # Видим, что это действительно класс Line. Опять же, магический метод __class__ доступен благодаря
# первоначальному наследованию от object (т.е. Line наследуется от Geom, а Geom от object). Также мы можем определять,
# является ли тот или иной класс подклассом другого класса, использую функцию issubclass(дочерний класс, базовый класс):
print(issubclass(Line, Geom))
print(issubclass(Geom, Line))
# print(issubclass(l, Geom))  # TypeError - данная функция не работает с экземплярами класса.
# Если нужно проверить принадлежность объекта к тому или иному классу (в т.ч. и базовому), то следует использовать
# другую функцию isinstance(объект, класс):
print(isinstance(l, Geom))  # True, ибо объект l является в т.ч. и производным от класса Geom.
print(isinstance(Geom, object))  # Функция так же позволяет первым аргументом принимать класс.

"""
Т.е. отличие функций isinstance() и issubclass() только к в том, что функция issubclass() работает только с классами,
а isinstance может работать и с объектами этих классов. 
Следует помнить, что все стандартные типы данных (int, float, str, list, dict и т.д.) также являются классами. В этом 
легко можно убедиться, если проверить их функцией issubclass():
"""
print(issubclass(int, object))  # Данная проверка нам даёт то, что int - это класс (ибо первым аргументом нельзя
# записать ничего, кроме класса, а также то, что класс int наследуется от базового класса object. И раз это так, то нам
# ничего не мешает встроенные типы данных расширить:

class Vector(list):
    def __str__(self):  # Теперь функция будет возвращать нам строку, состоящую из элементов списка, записанных
        # через пробел. self в данном случае и есть список - итерируемый объект. К каждому элементу списка применяем
        # функцию str(), а полученные строки записываем через пробел.
        return ' '.join(map(str, self))


v = Vector([1, 2, 3])  # Определяем класс Vector (по сути этот класс является классом list, но с переопределённым
# магическим методом __str__.
print(v)  # Таким образом, мы получили "1 2 3". А если бы не переопределяли __str__, то получили бы [1, 2, 3].
print(type(v))  # Тип объекта v не list, а Vector, ибо у нас новый класс Vector. Конечно, стандартные типы данных редко
# расширяют с помощью пользовательских классов, но понимать, что они представляют собой классы и что такая возможность
# в принципе существует, важно.
