"""
__iter__() - получение итератора для перебора объекта.
__next__() - переход к следующему значению и его считывание.

lst = [8, 5, 3, 1, 7]
Для любого итерируемого объекта можно получить итератор, т.е. некий интерфейс для перебора элементов
(в данном случае списка). Затем мы последовательно вызываем функцию next() и считываем последовательно элементы из
итерируемого объекта, получая на выходе определённые значения:
it = iter(lst) -> next(it) -> 8 -> 5 -> 3 -> 1 -> 7
Выше простой описан способ перебрать элементы любого итерируемого объекта, будь то: списки, строки, словари,
кортежи и т.д. В частности функция range(start, stop, step) тоже является итерируемым объектом и возвращает
арифметическую последовательность. Значения этой арифметической последовательности можно перебрать с помощью итератора.
"""

print(list(range(5)))  # Функция list() перебирает автоматически, но можно и создать итератор:
a = iter(range(5))  # А затем благодаря другой функции next() мы перебираем итератор:
print(next(a), next(a))  # Первый вызов даст 0, затем 1 и т.д. А если вызвать next() больше нужного (например, больше
# длины последовательности), то получим исключение StopIteration.


class FRange:
    """Класс будет возвращать арифметическую последовательность вещественных чисел."""
    def __init__(self, start=0.0, stop=0.0, step=0.0):
        self.start = start
        self.stop = stop
        self.step = step
        # self.value = self.start - self.step  # Таким образом, в следующей функции мы получим первое значение нашей
        # арифметической последовательности (P.s. до реализации __iter__ инициализация value была в __init__).

    def __iter__(self):
        self.value = self.start - self.step  # Таким образом, в следующей функции мы получим первое значение нашей
        # арифметической последовательности. Прописали value здесь, а не в инициализаторе потому что: каждый раз, когда
        # будем вызывать функцию iter() у нас value будет инициализироваться на начало арифметической последовательности

        return self  # Возвращаем объект self, потому что мы видели, что сам объект класса FRange и является итератором.
        # Поэтому, чтобы получить этот итератор, надо вернуть экземпляр этого класса.

    def __next__(self):  # По идее метод магический, но мы им воспользуемся в качестве обычного.
        if self.value + self.step < self.stop:
            self.value += self.step
            return self.value
        else:
            raise StopIteration
    # Внутри функции выше может быть любая логика, и перебор списков, словарей или что-то ещё, мы рассмотрели на
    # самом простом примере: примере арифметической последовательности.


fr = FRange(0, 2, 0.5)
print(fr.__next__())
print(fr.__next__())
print(fr.__next__())
print(next(fr))  # Благодаря наличию магического метода  __next__ эта запись эквивалентна записи выше. Т.е. метод next()
# неявно вызывает магический метод __next__, и то значение, которое вернёт магический метод, возвращает и функция
# next(), а сам объект fr выступает в роли итератора. Получается, что итератор - это некий объект, у которого есть
# магический метод __next__, а вызывает магический метод __next__ функция next().
# print(fr.__next__())  # На пятый раз срабатывает исключение, как мы и прописали.
# P.s.: после реализации магического метода __next__ с атрибутом value (т.е. после переноса value из __init__ в __next__
# строчки выше работать не будут (AttributeError: 'FRange' object has no attribute 'value').

# По идее, если мы создали итерируемый объект, то его можно перебрать с помощью цикла for:
for x in fr:
    print(x)  # До определения магического метода __iter__ получаем ошибку TypeError: 'FRange' object is not iterable.
# Ошибка возникла потому, что мы не можем создать итератор для объекта fr (не можем вызвать функцию iter()):
it = iter(fr)  # TypeError: 'FRange' object is not iterable. Пропишем же магический метод __iter__.
print(next(it), next(it), next(it), next(it))  # После реализации магического метода __iter__ ошибок нет ни в одной
# форме записи.


class FRange2D:
    """Этот класс будет формировать таблицу значений"""
    def __init__(self, start=0.0, stop=0.0, step=0.0, rows=5):  # Использовали тот же инициализатор. Но реализовали с
        # доп. параметром rows, а так же вместо прописи start, stop, range, создали экземпляр класса FRange.
        self.rows = rows
        self.fr = FRange(start, stop, step)  # Этот экземпляр класса так же будет формировать числа для каждой строки.

    # Далее создадим из этого класса FRange итератор, который можно обходить двумя вложенными циклами for.
    def __iter__(self):
        self.value = 0
        return self

    def __next__(self):
        if self.value < self.rows:
            self.value += 1
            return iter(self.fr)
        else:
            raise StopIteration
    """
    Таким образом данная функция возвращает не конкретное значение, а итератор, который, в свою очередь, будет
    возвращать конкретные числовые значения. Потому что итератор - это класс FRange в __init__, а именно он
    генерирует конкретные цифровые значения, т.е. в строках у нас уже будут получаться конкретные цифровые значения.
    """


fr2 = FRange2D(0, 2, 0.5, 4)
for row in fr2:  # row является итерируемым объектом, потому что в первой строчке мы получаем каждый раз в качестве
    # row итератор объекта FRange (82 сточка - итератор и 72 строчка - объект).
    for x in row:  # В этом цикле мы перебираем итератор FRange (на 72 строчке) и получаем конкретные цифровые значения.
        print(x, end=" ")  # Отображаем конкретные цифровые значения, которые получили.
    print()  # Для переноса курсора на новую строку.
