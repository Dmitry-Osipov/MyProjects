# __new__() - вызывается перед созданием объекта класса
#       ↓
# Объект класса
#       ↓
# __init__(self) - вызывается сразу после создания объекта класса

class Point:
    def __new__(cls, *args, **kwargs):  # cls - ссылается на текущий класс
        print("Вызов __new__ для " + str(cls))

    def __init__(self, x: int = 0, y: int = 0):  # self - ссылается на создаваемый экземпляр класса
        print("Вызов __init__ для: " + str(self))
        self.x = x
        self.y = y


pt = Point(1, 2)
print(pt)


# Вывод:
# Вызов __new__ для <class '__main__.Point'>
# т.е. метод __init__ вызван не был. Это говорит о том, что на самом деле в данный момент экземпляр класса pt не был
# создан. Убедиться в этом можно, распечатав то, на что ссылается pt. Почему так произошло?
# Метод __new__ должен возвращать адрес нового созданного объекта, а в программе он ничего не возвращает


class Point1:
    def __new__(cls, *args, **kwargs):  # cls - ссылается на текущий класс
        print("Вызов __new__ для " + str(cls))
        return super().__new__(cls)

    def __init__(self, x: int = 0, y: int = 0):  # self - ссылается на создаваемый экземпляр класса
        print("Вызов __init__ для: " + str(self))
        self.x = x
        self.y = y


pt1 = Point1(1, 2)
print(pt1)


"""
С версии Python 3 все создаваемые нами классы наследуются от класса object. Т.е. вызывая функцию
super() в классе Point, то мы получаем ссылку на базовый класс, и в этом базовом классе через эту ссылку
вызываем магический метод __new__. И этот магический метод __new__ запускает процесс создания экземпляра класса
и возвращает адрес нового созданного объекта. Убедиться в этом можно, выводя pt1.
Зачем прописывать *args и **kwargs? При передаче - pt1 = Point1(1, 2) - значения 1 и 2 передаются в
магический метод __new__. Убрав *args и **kwargs, мы получим ошибку
(метод __new__ ожидает передачу 1 аргумента, мы передаём 3)

Паттерн проектирования Singletone - при использовании класса в один момент времени в одной программе
должен быть создан только один экземпляр этого класса, т.е.:
Правильно:
db = DataBase('root', 1234, 80)
Неправильно:
db = DataBase('root', 1234, 80)
db2 = DataBase('root', 1234, 80)
"""

class DataBase:  # Данный класс должен быть реализован с учётом паттерна Singletone. Как это сделать?
    __instance = None  # Прописываем аттрибут класса. Он будет ссылкой на экземпляр класса.
    # Если его нет, то принимает значение None. А если будет, то будет ссылка на этот экземпляр класса.
    # Далее для реализации идеи нужно переопределить метод __new__

    def __new__(cls, *args, **kwargs):
        if cls.__instance is None:  # Если __instance принимает значение None, то мы создаём в строчке ниже
            # Новый экземпляр класса. Если __instance не None (т.е. уже создан какой-то объект, то
            # строчка ниже выполняться не будет, и мы вернём адрес ранее созданного объекта
            cls.__instance = super().__new__(cls)
        return cls.__instance

    def __del__(self):  # Если объект будет удалён сборщиком мусора, то атрибут __instance снова
        # будет принимать значение None, и мы сможем вновь создать объект этого класса
        DataBase.__instance = None

    def __init__(self, user, password, port):
        self.user = user
        self.password = password
        self.port = port

    def connect(self):
        print(f"Соединение с БД: {self.user}, {self.password}, {self.port}")

    def close(self):
        print("Закрытие соединения с БД")

    def read(self):
        return "Данные из БД"

    def write(self, data):
        print(f"Запись в БД: {data}")


db = DataBase('root', '1234', 80)
db1 = DataBase('root2', '5678', 40)
print(id(db), id(db1))  # id объектов одинаковое, что говорит о том, что при попытке создания второго объекта он
# на самом деле не был создан, и переменная db1 будет ссылаться на ранее созданный объект класса

db.connect()
db1.connect()
# Минус данной конструкции класса в том, что в обоих случаях (данные для db и db1) мы видим информацию,
# которую мы прописали при попытке создания второго объекта. Но мы не должны менять данные
# (менять данные можно только если мы это явно указываем). Исправить это можно, прописав
# магический метод __call__, о котором будет позже
