"""
В Python есть специальная функция hash(), вычисляющая хэш по определённому алгоритму для неизменяемых объектов.
Причём для равных объектов на выходе всегда будет получаться одинаковый хэш. Однако обратное утверждение не верно. Т.е.
если хэши одинаковые, то не обязательно, что объекты будут одинаковыми. Они могут быть разными, хотя это и происходит
крайне редко (как с селёдкой: каждая селёдка - это рыба, но не каждая рыба - это селёдка). Однако совершенно точно можно
сказать, что если хэши не равны, то и объекты не равны.
Если вкратце:
- Если объекты a == b (равны), то равен и хэш.
- Равные хэши: hash(a) == hash(b) - не гарантируют равенства объектов.
- Если хэши не равны: hash(a) != hash(b) - то объекты точно не равны.

Причём важно заметить, что вычислить хэш можно только для неизменяемых объектов. Если вызвать хэш для списка, то
получим ошибку. Изменяемые объекты являются не хэшируемыми.

print(hash('Python')) -> 6736137707351228305
print(hash(123)) -> 123
print(hash((1, 2, 3))) -> 529344067295497451
print(hash([1, 2, 3])) -> TypeError: unhashable type: 'list'

В действительности поэтому нельзя использовать не хэшируемые объекты в качестве ключа для словаря.
Т.е. когда мы прописываем:
d = {}
d[5] = 5
d['python'] = 'python'
d[(1, 2, 3)] = [1, 2, 3]
то словарь хранит ключи в виде коллекции (хэш ключа, сам ключ). Т.е. прежде чем сформировать ключ от него вычисляется
хэш и формируется кортеж из хэша + ключа. Но зачем дополнительно вычислять хэш? Дело в том, что первоначально запись
в словаре ищется как раз по хэшу (ибо существует быстрый алгоритм поиска нужного значения хэша), а затем для равных
хэшей (если таковые имеются) отбирается запись с указанным в ключе объекте. Такой подход значительно ускоряет поиск
значения в словаре.
"""


class Point:
    def __init__(self, x_coord, y_coord):
        self.x_coord = x_coord
        self.y_coord = y_coord

    def __eq__(self, other):  # Пропишем, что объекты с одинаковыми координатами равны.
        return self.x_coord == other.x_coord and self.y_coord == other.y_coord

    def __hash__(self):
        return hash((self.x_coord, self.y_coord))  # Изначально __hash__ принимает аргументом self, однако мы меняем
                                                   # аргумент на кортеж координат наших точек.


p1 = Point(1, 2)
p2 = Point(1, 2)

print(hash(p1), hash(p2), sep='\n')  # Хэши вычисляются, проблем нет, т.е. объекты класса Point воспринимаются как
# неизменяемые. Причём хэши получились разными, несмотря на то, что координаты точки одни и те же. Но как Python
# понимает, что это разные объекты?

print(p1 == p2)
"""
Если оператор сравнения выдаёт False, то это значит, что они разные. При True - одинаковые объекты.
Но что будет, если переопределить магический метод __eq__, который и отвечает за равенство объектов? Если после
определения этого магического метода вывести хэши объектов на экран, то мы получим TypeError. Дело в том, что когда
мы в своих пользовательских классах переопределяем магический метод __eq__ (который отвечает за проверку равенства),
то функция hash() перестаёт работать, ибо перестаёт работать стандартный алгоритм вычисления хэша. Как можно поправить
ситуацию, когда мы уже переопределили магический метод __eq__? Дополнительно требуется переопределить магический метод
__hash__, который и вызывается, когда вычисляется хэш для объектов p1 и p2. После определения магического метода
__hash__ всё работает без ошибок, но хэши получаются равными, ибо кортеж в обоих объектах содержит одни и те же
числовые значения. Т.е. мы подменили вычисление хэша объекта класса Point на вычисление хэша от координат точки.

Что в итоге нам это даёт? Если мы формируем какой-либо словарь и далее в качестве ключей этого словаря укажем
первый объект (p1) и присвоим 1, и укажем второй объект (p2) и присвоим 2, а затем с помощью функции print выведем
этот словарь в консоль, то увидим следующее: в словаре всего 1 ключ в виде объекта класса Point со значением 2. Что
говорит о том объекты p1 и p2 сейчас воспринимаются как один и тот же ключ (ибо хэши равны и оператор сравнения на
равенство объектов так же выдаёт True). Т.е. это для словаря один и тот же ключ. Но если в классе убрать реализацию
двух магический методов __eq__ и __hash__, то мы получим 2 разных ключа. 

Таким образом, переопределив 2 магических метода __eq__ и __hash__, мы получаем, что теперь Python будет воспринимать 
эти 2 объекта класса как 1. Для этого и требуется тонко настраивать работу функции __hash__.
"""

d = {}
d[p1] = 1
d[p2] = 2
print(d)
