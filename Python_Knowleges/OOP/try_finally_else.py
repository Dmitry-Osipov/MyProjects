"""
Помимо стандартных try и except на практике также часто прописывают необязательные блоки finally и else.
Блок else отвечает за отработку определённой части кода при штатном выполнении программы. Т.е. когда не было ошибок.
Вторым необязательным блоком является finally, который, наоборот, выполняется всегда вне зависимости от того, произошла
ли ошибка.
"""

try:
    x, y = map(int, input('Введите целые числа: ').split())
    res = x / y
except ValueError as z:  # Теперь переменная z будет являться ссылкой на экземпляр класса исключения ValueError.
    # Далее можно использовать этот объект для вывода исключения в консоли.
    print(z)  # Теперь вылезет стандартное сообщение, которое заложено в классе ValueError.
except ZeroDivisionError as z:  # Можно также указать z, ибо это будут совершенно независимые переменные.
    print(z)  # Для ZeroDivisionError выведет division by zero.
else:
    print('Не произошло никаких исключений')  # Если произойдёт хотя бы одна любая ошибка, то мы не увидим этой строки.
finally:
    print('Блок finally выполняется всегда')

"""
Классический пример работы блока finally - это работа с файлами. Если выполнить код ниже (при условии существования
файла), то мы получаем ошибку. Ибо пытаемся записать что-то в файл, когда он открыт только на чтение. В итоге, файл не
будет закрыт, хотя его обязательно нужно закрывать даже при возникновении ошибок. Как раз для этого может пригодиться
блок finally, в котором мы и будем закрывать этот файл.
"""

try:
    f = open('myfile.txt')
    f.write('hello')
except FileNotFoundError as z:
    print(z)
except:
    print('Другая ошибка')
finally:
    if f:
        f.close()
        print('Файл закрыт')

"""
Следующая особенность работы блока finally связана с обработкой исключений внутри функции. Предположим, что в некой
функции вводится 2 целых значения и возвращается в виде кортежа.
"""


def get_values():
    try:
        x, y = map(int, input('Введите 2 целых числа: ').split())
        return (x, y)
    except ValueError as z:
        print(z)
        return 0, 0  # Если x и/или y были введены некорректно, то мы возвращаем кортеж из нулей.
    finally:
        print('finally выполняется до оператора return')


x, y = get_values()
print(x, y)  # Требуется хорошо понимать, что оператор return отрабатывает в самую последнюю очередь. Иначе бы не
# получили реализации блока finally. Блоки try-except можно вкладывать друг в друга:

try:
    x, y = map(int, input('Введите 2 целых числа: ').split())
    try:
        res = x / y
    except ZeroDivisionError as z:
        print(z)
except ValueError as z:
    print(z)


# Ещё можно вынести реализацию try-except в отдельную функцию.


def div(a, b):
    try:
        return a / b
    except ZeroDivisionError as z:
        return z


res = -1
try:
    x, y = map(int, input('Введите 2 целых числа: ').split())
    res = div(x, y)
except ValueError as z:
    print(z)

print(res)
