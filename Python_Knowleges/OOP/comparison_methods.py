"""
Магические методы сравнений:
__eq__() - для равенства ==
__ne__() - для неравенства !=
__lt__() - для оператора меньше <
__le__() - для оператора меньше или равно <=
__gt__() - для оператора больше >
__ge__() - для оператора больше или равно >=
"""


class Clock:
    __DAY = 86400  # Число секунд в одном дне.

    def __init__(self, seconds: int):
        if not isinstance(seconds, int):
            raise TypeError('Секунды должны быть целым числом')

        self.seconds = seconds % self.__DAY

    @classmethod  # Для отсутствия дублирования кода создаём метод на уровне класса
    def __verify_data(cls, other):
        if not isinstance(other, (int, Clock)):
            raise TypeError('Операнд справа должен быть целым числом или объектом класса Clock')

        return other if isinstance(other, int) else other.seconds

    def __eq__(self, other):
        sc = self.__verify_data(other)
        return self.seconds == sc

    def __lt__(self, other):
        sc = self.__verify_data(other)
        return self.seconds < sc

    def __le__(self, other):
        sc = self.__verify_data(other)
        return self.seconds <= sc

    def __gt__(self, other):
        sc = self.__verify_data(other)
        return self.seconds > sc


c1 = Clock(1000)
c2 = Clock(1000)
c3 = Clock(3000)

print(c1 == c2)  # До определения магического метода мы видим False. Т.е. сравнение по умолчанию организовано так что
# сравниваются id для c1 и c2. А нам нужно сравнить время, которое они хранят. Для этого определяем магические методы.
# После определения магического метода сравнения мы видим True.

print(c1 != c3)
print(c2 != 1200)  # Мы имеем правильный вывод. Но как это получилось без определения соответствующего магического
# метода? Дело в том, что интерпретатор Python когда видит оператор неравенства и этот оператор не реализован в
# классе, то пытается выполнить операцию not(c2 == 1200), где используется оператор равенства (а оператор равенства
# мы уже определили).

print(c1 < c3)  # Однако если сравнивать значение другими операторами (до реализации магического метода __lt__, то мы
# получим TypeError, ибо такого сравнения мы явно не прописали, а по умолчанию эта операция никак не реализуется.
# Для сравнения другими операторами надо прописать соответствующие магические методы.
print(c1 > c3)  # До реализации магического метода __gt__ данная строчка так же сработает, почти логике выше, т.е.
# интерпретатор устраивает подмену операндов местами. В данном случае во время выполнения строчки c1 > c3 интерпретатор
# меняет строчку на c3 > c1. А когда мы определим магический метод __gt__, то будет вызываться именно этот метод,
# что можно увидеть в режиме отладки кода.

print(c1 <= c2)  # До определения магического метода __le__ мы получаем ошибку TypeError. После его определения всё
# точь-в-точь так же (и с оператором >= тоже).
print(c1 >= c3)

"""
Таким образом, для операций сравнения в классе достаточно определить 3 метода вместо 6 (__eq__, __lt__, __le__), 
а другие сравнения будут работать в инверсном режиме.
"""
