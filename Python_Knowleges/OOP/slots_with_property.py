class Point2D:
    __slots__ = ('x', 'y', 'length')

    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.length = (x * x + y * y) ** 0.5  # Теперь при создании класса свойство length появится автоматически.


pt = Point2D(1, 2)
print(pt.length)  # Мы смогли к этому свойству обратиться. Но что будет, если прописать в классе прописать свойство с
# тем же самым именем (свойство property)?


class Point2D:
    __slots__ = ('x', 'y', '__length')

    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.__length = (x * x + y * y) ** 0.5

    @property
    def length(self):  # Это геттер, так что возвращаем значение.
        return self.__length  # Взял 2 подчёркивания, потому что локальное свойство должно отличаться от функции.

    @length.setter
    def length(self, value):
        self.__length = value


pt = Point2D(1, 2)
print(pt.length)  # Отработало без ошибок, и мы получили значение точь-в-точь предыдущему. Более того, мы можем что-то
# записать в length, ибо у нас есть сеттер.
pt.length = 10
print(pt.length)
"""
Т.е. несмотря на то, что мы как бы не разрешаем свойство length, тем не менее оно доступно и мы можем через него 
спокойно работать. В целом, так и должно быть, ибо length - это не локальное свойство экземпляра класса, а атрибут 
класса класса. Коллекция __slots__ запрещает только локальные свойства экземпляров класса и не накладывает ограничений 
на атрибуты самого класса. 
Также важно рассмотреть: как работает коллекция __slots__ при наследовании классов.
"""


class Point2D:
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x = x
        self.y = y


class Point3D(Point2D):
    pass


pt3 = Point3D(10, 20)
pt3.z = 30  # При реализации выше коллекция __slots__ не наследуется, что даёт создавать новые переменные.
print(pt3.__dict__)  # В коллекции __dict__ мы видим только z, ибо локальные свойства x и y "забронировала" за собой
# коллекция __slots__ в родительском классе. Это будет работать, даже если удалить, а затем заново присвоить x:
del pt3.x
pt3.x = 23
print(pt3.__dict__)
"""
Благодаря этому можно сделать простой вывод: если в классе Point3D коллекцию __slots__() даже пустой, то значит в нём 
будут разрешены только эти 2 локальных свойства x и y.
"""


class Point2D:
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x = x
        self.y = y


class Point3D(Point2D):
    __slots__ = ()


pt3 = Point3D(10, 20)  # Даже несмотря на пустую запись коллекции __slots__ мы можем создавать локальные свойства
# x и y, потому что они берутся из базового класса Point2D. В чём можно убедиться, попытавшись обратиться к x или y.
print(pt3.x, pt3.y)
pt3.z = 90  # AttributeError: 'Point3D' object has no attribute 'z'
"""
Если мы хотим иметь возможность для реализации третьего локального свойства для Point3D, то нужно изменить коллекцию 
__slots__ в дочернем классе.
"""


class Point2D:
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x = x
        self.y = y


class Point3D(Point2D):
    __slots__ = 'z',  # Важно прописать через запятую, ибо __slots__ должна быть коллекцией, в данном случае, кортеж.

    def __init__(self, x, y, z):  # Чтобы всё красиво работало, то следует прописать инициализатор, дабы потом не
                                  # прописывать вручную локальное свойство z
        super().__init__(x, y)
        self.z = z


pt3 = Point3D(10, 20, 30)
print(pt3.x, pt3.y, pt3.z)
