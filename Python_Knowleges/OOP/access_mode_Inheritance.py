"""
Режимы доступа:
Attribute (без одного или двух подчёркиваний в начале) - публичное свойство (public).
_Attribute (с одним подчёркиванием) - режим доступа protected (служит для обращения внутри класса и во всех
 его дочерних классах).
__Attribute (с двумя подчёркиваниями) - режим доступа private (служит для обращения только внутри класса).
Узнаем, как влияют режимы доступа private и protected при наследовании класса.
"""


class Geom:
    name = 'Geom'

    def __init__(self, x1, y1, x2, y2):
        print(f'Инициализатор для {self.__class__}')
        self.__x1 = x1
        self.__y1 = y1
        self.__x2 = x2
        self.__y2 = y2


class Rect(Geom):
    def __init__(self, x1, y1, x2, y2, fill='red'):
        super().__init__(x1, y1, x2, y2)
        self.__fill = fill


r = Rect(0, 0, 10, 20)  # '_Geom__x1': 0, '_Geom__y1': 0, '_Geom__x2': 10, '_Geom__y2': 20,
                                       # '_Rect__fill': 'red'
print(r.__dict__)
"""
При приватном режиме доступа у нас добавляется префикс родительского класса, несмотря на то,
что параметр self сейчас является ссылкой на объект класса Rect. Это особенность поведения формирования приватных
атрибутов в базовых классах. А последнее свойство fill, т.к. оно было создано непосредственно в классе Rect имеет
префикс этого класса Rect. Таким образом, в том классе, где прописаны приватные свойства, тот префикс и добавляется.
Из этого следует, что мы не можем обратиться к приватным свойствам (x1, y1 ...) в дочернем классе. Убедимся в этом, 
прописав метод, возвращающий координату графического примитива:
"""


# class Geom:
#     name = 'Geom'
#
#     def __init__(self, x1, y1, x2, y2):
#         print(f'Инициализатор для {self.__class__}')
#         self.__x1 = x1
#         self.__y1 = y1
#         self.__x2 = x2
#         self.__y2 = y2
#
#
# class Rect(Geom):
#     def __init__(self, x1, y1, x2, y2, fill='red'):
#         super().__init__(x1, y1, x2, y2)
#         self.__fill = fill
#
#     def get_coords(self):
#         return (self.__x1, self.__y1)
#
#
# r = Rect(0, 0, 10, 20)
# r.get_coords()  # AttributeError: 'Rect' object has no attribute '_Rect__x1'. Did you mean: '_Geom__x1'?
# print(r.__dict__)
# Однако, если метод get_coords() поместить в базовый класс, то проблем не будет:


class Geom:
    name = 'Geom'

    def __init__(self, x1, y1, x2, y2):
        print(f'Инициализатор для {self.__class__}')
        self.__x1 = x1
        self.__y1 = y1
        self.__x2 = x2
        self.__y2 = y2

    def get_coords(self):
        return (self.__x1, self.__y1)


class Rect(Geom):
    def __init__(self, x1, y1, x2, y2, fill='red'):
        super().__init__(x1, y1, x2, y2)
        self.__fill = fill


r = Rect(1, 2, 1, 2)
print(r.get_coords())  # (1, 2)
print(r.__dict__)

"""
Данное поведение может показаться запутанным и странным, но нужно вспомнить - для чего вообще нужны режимы доступа:
__Attribute (с двумя подчёркиваниями) - режим доступа private (служит для обращения только внутри класса) - это закрытые 
от внешнего вмешательства свойства или методы текущего класса, доступные только внутри этого класса и не доступные из 
других, в т.ч. и из дочерних классов. Поэтому приватные атрибуты жёстко привязываются к текущему классу, в котором 
они создаются. Т.е. по логике их предполагается использовать только внутри базового класса (в нашем случае, Geom).
Если же нам нужно определить закрытый атрибуты, доступные в текущем классе, а также во всех его дочерних классах, то 
следует использовать определение protected:
"""


class Geom:
    name = 'Geom'

    def __init__(self, x1, y1, x2, y2):
        print(f'Инициализатор для {self.__class__}')
        self._x1 = x1
        self._y1 = y1
        self._x2 = x2
        self._y2 = y2


class Rect(Geom):
    def __init__(self, x1, y1, x2, y2, fill='red'):
        super().__init__(x1, y1, x2, y2)
        self.__fill = fill

    def get_coords(self):
        return (self._x1, self._y1)


r = Rect(1, 2, 1, 2)
print(r.get_coords())  # (1, 2)
print(r.__dict__)  # '_x1': 1, '_y1': 2, '_x2': 1, '_y2': 2, '_Rect__fill': 'red'
"""
Повторимся: режим доступа protected не запрещает нам обращаться к тому или иному атрибуту извне. Нижнее подчёркивание 
лишь предупреждает, сигнализирует программисту, что атрибут является защищённым, к которому напрямую лучше не 
обращаться - этот атрибут был создан для внутренней логике работы алгоритмов в классе и не предназначен для прямого 
обращения извне (print(r._y2)). Ибо в дальнейшем это может привести к проблемам. Например, при изменении версии классов, 
в которых такого атрибута уже не будет (или же он будет играть другую роль).
Похожим образом себя ведут атрибуты и уровня класса. Сейчас в базовом классе есть атрибут с именем (name), и мы можем 
спокойно к нему обратиться (print(r.name)), но если сменить режим доступа на приватный в базовом классе (__name = ...),
то напрямую мы обратиться не сможем ни извне (print(r.__name) - AttributeError), ни внутри класса Rect (например, 
прописав внутри инициализатора Rect следующую строку - self.__name = Geom.__name - мы всё равно получим ошибку).
Всё сработает только если обращаться к приватному атрибуту только внутри базового класса, где он был создан (например, 
прописав в инициализаторе базового класса следующее: self._name = self.__name - далее при обращении к локальным 
переменным экземпляра класса Rect мы увидим, что _name ссылается на 'Geom').
Те же ограничения доступа можно накладывать и на методы. Если в базовом классе прописать приватный метод, то этот 
приватный метод можно использовать только в экземпляре класса Geom, для дочерних классов такого метода нет.

В этом и отличие двух режимов доступа: protected используется для защиты атрибутов от внешнего вмешательства, но все эти 
атрибуты доступны внутри того класса, где определены и во всех его дочерних классах; а private - доступны только в том 
классе, где они непосредственно определены.  
"""
